{"version":3,"file":"index.esm.js","sources":["../src/support/supports-relative-time-format.ts","../src/locale-matcher/locale-matcher.ts","../src/style/style.ts","../src/numeric/numeric.ts","../src/unit/singular-relative-time-unit.ts","../src/util/to-object.ts","../src/util/to-string.ts","../src/relative-time-format/unicode-extension/unicode-extension.ts","../src/relative-time-format/matcher/best-available-locale/best-available-locale.ts","../src/relative-time-format/default-locale/get-default-locale.ts","../src/relative-time-format/matcher/lookup-matcher/lookup-matcher.ts","../src/relative-time-format/matcher/best-fit-matcher/best-fit-matcher.ts","../src/assert/is-record.ts","../src/assert/is-list.ts","../src/util/same-value.ts","../src/relative-time-format/resolve-locale/resolve-locale.ts","../src/relative-time-format/supported-locales/lookup-supported-locales.ts","../src/relative-time-format/supported-locales/best-fit-supported-locales.ts","../src/util/is-property-key.ts","../src/util/get.ts","../src/util/to-boolean.ts","../src/util/get-option.ts","../src/relative-time-format/supported-locales/supported-locales.ts","../src/relative-time-format/internal-slot/internal-slot.ts","../src/relative-time-format/resolve-plural/resolve-plural.ts","../src/relative-time-format/make-parts-list/make-parts-list.ts","../src/relative-time-format/partition-relative-time-pattern/partition-relative-time-pattern.ts","../src/relative-time-format/format-relative-time/format-relative-time.ts","../src/relative-time-format/format-relative-time-to-parts/format-relative-time-to-parts.ts","../src/util/to-number.ts","../src/relative-time-format/relative-time-format/relative-time-format.ts","../src/patch/patch.ts","../src/index.ts"],"sourcesContent":["export const SUPPORTS_RELATIVE_TIME_FORMAT = \"RelativeTimeFormat\" in Intl;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const LOCALE_MATCHER = [\"lookup\", \"best fit\"] as const;\n\nexport type LocaleMatcher = ElementOf<typeof LOCALE_MATCHER>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const STYLE = [\"long\", \"short\", \"narrow\"] as const;\n\nexport type Style = ElementOf<typeof STYLE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const NUMERIC = [\"always\", \"auto\"] as const;\n\nexport type Numeric = ElementOf<typeof NUMERIC>;\n","import {RelativeTimeUnit} from \"./relative-time-unit\";\n\nexport type SingularRelativeTimeUnit = \"second\" | \"minute\" | \"hour\" | \"day\" | \"week\" | \"month\" | \"quarter\" | \"year\";\n\nexport type ExtendedSingularRelativeTimeUnit =\n\t| SingularRelativeTimeUnit\n\t| \"second-narrow\"\n\t| \"second-short\"\n\t| \"minute-narrow\"\n\t| \"minute-short\"\n\t| \"hour-narrow\"\n\t| \"hour-short\"\n\t| \"day-narrow\"\n\t| \"day-short\"\n\t| \"week-narrow\"\n\t| \"week-short\"\n\t| \"month-narrow\"\n\t| \"month-short\"\n\t| \"quarter-narrow\"\n\t| \"quarter-short\"\n\t| \"year-narrow\"\n\t| \"year-short\";\n\nconst VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES: SingularRelativeTimeUnit[] = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"];\n\nexport const VALID_EXTENDED_SINGULAR_RELATIVE_TIME_UNIT_VALUES: ExtendedSingularRelativeTimeUnit[] = [\n\t...VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES,\n\t\"second-narrow\",\n\t\"second-short\",\n\t\"minute-narrow\",\n\t\"minute-short\",\n\t\"hour-narrow\",\n\t\"hour-short\",\n\t\"day-narrow\",\n\t\"day-short\",\n\t\"week-narrow\",\n\t\"week-short\",\n\t\"month-narrow\",\n\t\"month-short\",\n\t\"quarter-narrow\",\n\t\"quarter-short\",\n\t\"year-narrow\",\n\t\"year-short\"\n];\n\n/**\n * Sanitizes a RelativeTimeUnit into a SingularRelativeTimeUnit\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-singularrelativetimeunit\n * @param {RelativeTimeUnit} unit\n * @return {SingularRelativeTimeUnit}\n */\nexport function singularRelativeTimeUnit(unit: RelativeTimeUnit): SingularRelativeTimeUnit {\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`unit: '${unit}' must be a string`);\n\t}\n\n\t// If unit is \"seconds\", return \"second\".\n\tif (unit === \"seconds\") return \"second\";\n\n\t// If unit is \"minutes\", return \"minute\".\n\tif (unit === \"minutes\") return \"minute\";\n\n\t// If unit is \"hours\", return \"hour\".\n\tif (unit === \"hours\") return \"hour\";\n\n\t// If unit is \"days\", return \"day\".\n\tif (unit === \"days\") return \"day\";\n\n\t// If unit is \"weeks\", return \"week\".\n\tif (unit === \"weeks\") return \"week\";\n\n\t// If unit is \"months\", return \"month\".\n\tif (unit === \"months\") return \"month\";\n\n\t// If unit is \"quarters\", return \"quarter\".\n\tif (unit === \"quarters\") return \"quarter\";\n\n\t// If unit is \"years\", return \"year\".\n\tif (unit === \"years\") return \"year\";\n\n\t// If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", or \"year\", throw a RangeError exception.\n\tif (!VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.some(validUnit => validUnit === unit)) {\n\t\tthrow new RangeError(`Unit: '${unit}' must be one of: ${VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.map(val => `\"${val}\"`).join(\", \")}`);\n\t}\n\n\t// Return unit.\n\treturn unit;\n}\n","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @return {T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","/**\n * The abstract operation ToString converts argument to a value of type String\n * https://tc39.es/ecma262/#sec-tostring\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toString(argument: unknown): string {\n\treturn argument + \"\";\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @return {string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n\n/**\n * The abstract operation UnicodeExtensionValue is called with extension, which must be a Unicode locale extension sequence,\n * and String key. This operation returns the type subtags for key.\n * @param {string} extension\n * @param {string} key\n * @returns {string?}\n */\nexport function unicodeExtensionValue(extension: string, key: string): string | undefined {\n\t// Assert: The number of elements in key is 2.\n\tif (key.length !== 2) {\n\t\tthrow new TypeError(`Could not get UnicodeExtensionValue: The given key: '${key}' must have a length of 2`);\n\t}\n\n\t// Let size be the number of elements in extension.\n\tconst size = key.length;\n\n\t// Let searchValue be the concatenation of \"-\", key, and \"-\".\n\tlet searchValue = `-${key}-`;\n\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tlet pos = String.prototype.indexOf.call(extension, searchValue);\n\n\t// If pos ≠ -1, then\n\tif (pos !== -1) {\n\t\t// Let start be pos + 4.\n\t\tconst start = pos + 4;\n\t\t// Let end be start.\n\t\tlet end = start;\n\t\t// Let k be start.\n\t\tlet k = start;\n\t\t// Let done be false.\n\t\tlet done = false;\n\n\t\t// Repeat, while done is false\n\t\twhile (!done) {\n\t\t\t// Let e be Call(%StringProto_indexOf%, extension, « \"-\", k »).\n\t\t\tconst e = String.prototype.indexOf.call(extension, \"-\", k);\n\n\t\t\t// If e = -1, let len be size - k; else let len be e - k.\n\t\t\tconst len = e === -1 ? size - k : e - k;\n\n\t\t\t// If len = 2, then\n\t\t\tif (len === 2) {\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else if e = -1, then\n\t\t\telse if (e === -1) {\n\t\t\t\t// Let end be size.\n\t\t\t\tend = size;\n\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else,\n\t\t\telse {\n\t\t\t\t// Let end be e.\n\t\t\t\tend = e;\n\n\t\t\t\t// Let k be e + 1.\n\t\t\t\tk = e + 1;\n\t\t\t}\n\t\t}\n\t\t// Return the String value equal to the substring of extension consisting of\n\t\t// the code units at indices start (inclusive) through end (exclusive).\n\t\treturn extension.slice(start, end);\n\t}\n\n\t// Let searchValue be the concatenation of \"-\" and key.\n\tsearchValue = `-${key}`;\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tpos = String.prototype.indexOf.call(extension, searchValue);\n\t// If pos ≠ -1 and pos + 3 = size, then\n\tif (pos !== -1 && pos + 3 === size) {\n\t\t// Return the empty String.\n\t\treturn \"\";\n\t}\n\n\t// Return undefined.\n\treturn undefined;\n}\n","import {Locales} from \"../../../locale/locales\";\nimport {Locale} from \"../../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @return {string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {Locale} from \"../../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @return {Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @return {Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = {} as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * RelativeTimeFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","/**\n * The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevaluenonnumber\n * @param {Exclude<*, number>} x\n * @param {Exclude<*, number>} y\n * @return {boolean}\n */\nfunction sameValueNonNumber(x: Exclude<unknown, number>, y: Exclude<unknown, number>): boolean {\n\t// Assert: Type(x) is not Number.\n\tif (typeof x === \"number\") {\n\t\tthrow new TypeError(`First argument 'x' must not be a number`);\n\t}\n\n\t// Assert: Type(x) is the same as Type(y).\n\tif (typeof x !== typeof y) {\n\t\tthrow new TypeError(`The given arguments must have the same type`);\n\t}\n\n\t// If Type(x) is Undefined, return true.\n\tif (x === undefined) return true;\n\n\t// If Type(x) is Null, return true.\n\tif (x === null) return true;\n\n\t// If Type(x) is String, then\n\tif (typeof x === \"string\") {\n\t\t// If x and y are exactly the same sequence of code units\n\t\t// (same length and same code units at corresponding indices), return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Boolean, then\n\tif (typeof x === \"boolean\") {\n\t\t// If x and y are both true or both false, return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Symbol, then\n\tif (typeof x === \"symbol\") {\n\t\t// If x and y are both the same Symbol value, return true; otherwise, return false.\n\t\treturn x.valueOf() === (y as symbol).valueOf();\n\t}\n\n\t// If x and y are the same Object value, return true. Otherwise, return false.\n\treturn x === y;\n}\n\n/**\n * The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevalue\n * @param {*} x\n * @param {*} y\n * @return {boolean}\n */\nexport function sameValue(x: unknown, y: unknown): boolean {\n\t// If Type(x) is different from Type(y), return false.\n\tif (typeof x !== typeof y) return false;\n\n\t// If Type(x) is Number, then\n\tif (typeof x === \"number\") {\n\t\t// If x is NaN and y is NaN, return true.\n\t\tif (isNaN(x) && isNaN(y as number)) return true;\n\n\t\t// If x is +0 and y is -0, return false.\n\t\tif (Object.is(x, 0) && Object.is(y, -0)) return false;\n\n\t\t// If x is the same Number value as y, return true.\n\t\tif (x === y) return true;\n\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// Return SameValueNonNumber(x, y).\n\treturn sameValueNonNumber(x, y);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {isRecord} from \"../../assert/is-record\";\nimport {isList} from \"../../assert/is-list\";\nimport {unicodeExtensionValue} from \"../unicode-extension/unicode-extension\";\nimport {sameValue} from \"../../util/same-value\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelevantExtensionKey} from \"../../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} relevantExtensionKeys\n * @param {LocaleData} localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\trelevantExtensionKeys: RelevantExtensionKey[],\n\tlocaleData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = {} as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tlet supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\tfor (const key of relevantExtensionKeys) {\n\t\t// Let foundLocaleData be localeData.[[<foundLocale>]].\n\t\tconst foundLocaleData = localeData[foundLocale];\n\n\t\t// Assert: Type(foundLocaleData) is Record.\n\t\tif (!isRecord(foundLocaleData)) {\n\t\t\tthrow new TypeError(`LocaleData for locale: '${foundLocale}' must be an object`);\n\t\t}\n\n\t\t// Let keyLocaleData be foundLocaleData.[[<key>]].\n\t\tconst keyLocaleData = foundLocaleData[key];\n\n\t\t// Assert: Type(keyLocaleData) is List.\n\t\tif (!isList(keyLocaleData)) {\n\t\t\tthrow new TypeError(`key: '${key}' in LocaleData for locale: '${foundLocale}' must be indexable`);\n\t\t}\n\n\t\t// Let value be keyLocaleData[0].\n\t\tlet value = keyLocaleData[0];\n\n\t\t// Assert: Type(value) is either String or Null.\n\t\tif (typeof value !== \"string\" && value !== null) {\n\t\t\tthrow new TypeError(`value: '${value}' for key: '${key}' in LocaleData for locale: '${foundLocale}' must be a string or null`);\n\t\t}\n\n\t\t// Let supportedExtensionAddition be \"\".\n\t\tlet supportedExtensionAddition = \"\";\n\n\t\t// If r has an [[extension]] field, then\n\t\tif (\"extension\" in r) {\n\t\t\t// Let requestedValue be UnicodeExtensionValue(r.[[extension]], key).\n\t\t\tconst requestedValue = unicodeExtensionValue(r.extension!, key);\n\n\t\t\t// If requestedValue is not undefined, then\n\t\t\tif (requestedValue !== undefined) {\n\t\t\t\t// If requestedValue is not the empty String, then\n\t\t\t\tif (requestedValue !== \"\") {\n\t\t\t\t\t// If keyLocaleData contains requestedValue, then\n\t\t\t\t\tif (keyLocaleData.includes(requestedValue)) {\n\t\t\t\t\t\t// Let value be requestedValue.\n\t\t\t\t\t\tvalue = requestedValue;\n\n\t\t\t\t\t\t// Let supportedExtensionAddition be the concatenation of \"-\", key, \"-\", and value.\n\t\t\t\t\t\tsupportedExtensionAddition = `-${key}-${value}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Else if keyLocaleData contains \"true\", then\n\t\t\t\telse if (keyLocaleData.includes(\"true\")) {\n\t\t\t\t\t// Let value be \"true\".\n\t\t\t\t\tvalue = \"true\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If options has a field [[<key>]], then\n\t\tif (\"key\" in options) {\n\t\t\t// Let optionsValue be options.[[<key>]].\n\t\t\tconst optionsValue = options.key;\n\n\t\t\t// Assert: Type(optionsValue) is either String, Undefined, or Null.\n\t\t\tif (typeof optionsValue !== \"string\" && optionsValue != null) {\n\t\t\t\tthrow new TypeError(`options value: '${optionsValue}' must be a string, undefined, or null`);\n\t\t\t}\n\n\t\t\t// If keyLocaleData contains optionsValue, then\n\t\t\tif (optionsValue !== undefined && keyLocaleData.includes(optionsValue)) {\n\t\t\t\t// If SameValue(optionsValue, value) is false, then\n\t\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\t\tif (!sameValue(optionsValue, value)) {\n\t\t\t\t\t// Let value be optionsValue.\n\t\t\t\t\tvalue = optionsValue;\n\t\t\t\t\t// Let supportedExtensionAddition be \"\".\n\t\t\t\t\tsupportedExtensionAddition = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set result.[[<key>]] to value.\n\t\tresult[key] = value;\n\n\t\t// Append supportedExtensionAddition to supportedExtension.\n\t\tsupportedExtension += supportedExtensionAddition;\n\t}\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","/**\n * The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.\n * https://tc39.es/ecma262/#sec-ispropertykey\n * @param {*} argument\n * @returns {boolean}\n */\nexport function isPropertyKey(argument: unknown): argument is PropertyKey {\n\t// If Type(argument) is String, return true.\n\tif (typeof argument === \"string\") return true;\n\t// If Type(argument) is Symbol, return true.\n\tif (typeof argument === \"symbol\") return true;\n\t// Return false.\n\treturn false;\n}\n","import {isPropertyKey} from \"./is-property-key\";\n\n/**\n * The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key.\n * https://tc39.es/ecma262/#sec-get-o-p\n * @param {O} o\n * @param {P} p\n * @returns {O[P]}\n */\nexport function get<O extends object, P extends keyof O>(o: O, p: P): O[P] {\n\t// Assert: Type(O) is Object.\n\tif (typeof o !== \"object\") {\n\t\tthrow new TypeError(`Given argument ${o} must be of type Object`);\n\t}\n\n\t// Assert: IsPropertyKey(P) is true.\n\tif (!isPropertyKey(p)) {\n\t\tthrow new TypeError(`Given argument ${p} must be a PropertyKey`);\n\t}\n\treturn o[p];\n}\n","/**\n * The abstract operation ToBoolean converts argument to a value of type Boolean\n * https://tc39.es/ecma262/#sec-toboolean\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toBoolean(argument: unknown): boolean {\n\treturn Boolean(argument);\n}\n","import {get} from \"./get\";\nimport {toBoolean} from \"./to-boolean\";\nimport {toString} from \"./to-string\";\nimport {ElementOf} from \"./element-of\";\n\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param {Options} options\n * @param {Property} property\n * @param {Type} type\n * @param {Values} values\n * @param {Fallback} fallback\n * @returns {Return}\n */\nexport function getOption<\n\tOptions extends object,\n\tProperty extends keyof Options,\n\tType extends Options[Property] extends (string | (string | undefined)) ? \"string\" : \"boolean\",\n\tValues extends Options[Property] extends (string | (string | undefined)) ? readonly string[] : readonly boolean[],\n\tFallback extends ElementOf<Values>,\n\tReturn extends ElementOf<Values>\n>(options: Options, property: Property, type: Type, values: Values, fallback: Fallback): Return {\n\t// Let value be ? Get(options, property).\n\tlet value = get(options, property);\n\t// If value is not undefined, then\n\tif (value !== undefined) {\n\t\t// Assert: type is \"boolean\" or \"string\".\n\t\tif (type !== \"boolean\" && type !== \"string\") {\n\t\t\tthrow new TypeError(`Expected type ${type} to be 'boolean' or 'string`);\n\t\t}\n\n\t\t// If type is \"boolean\", then\n\t\tif (type === \"boolean\") {\n\t\t\t// Let value be ToBoolean(value).\n\t\t\tvalue = (toBoolean(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If type is \"string\", then\n\t\tif (type === \"string\") {\n\t\t\t// Let value be ? ToString(value).\n\t\t\tvalue = (toString(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If values is not undefined, then\n\t\tif (values !== undefined) {\n\t\t\t// If values does not contain an element equal to value, throw a RangeError exception.\n\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\tif (!values.includes(value as never)) {\n\t\t\t\tthrow new RangeError(`Value ${value} out of range for options property ${property}`);\n\t\t\t}\n\t\t}\n\n\t\t// Return value.\n\t\treturn (value as unknown) as Return;\n\t}\n\n\t// Else, return fallback.\n\telse {\n\t\treturn (fallback as unknown) as Return;\n\t}\n}\n","import {Locales} from \"../../locale/locales\";\nimport {toObject} from \"../../util/to-object\";\nimport {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\nimport {LOCALE_MATCHER, LocaleMatcher} from \"../../locale-matcher/locale-matcher\";\nimport {getOption} from \"../../util/get-option\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @return {Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\tlet matcher: LocaleMatcher;\n\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\n\t\tmatcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\t}\n\n\t// Else, let matcher be \"best fit\".\n\telse {\n\t\tmatcher = \"best fit\";\n\t}\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\"\n\t\t? bestFitSupportedLocales(availableLocales, requestedLocales)\n\t\t: lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeFormatInstanceInternals} from \"./relative-time-format-instance-internals\";\nimport {RelativeTimeFormatStaticInternals} from \"./relative-time-format-static-internals\";\n\n/**\n * A WeakMap between RelativeTimeFormat instances and their internal slot members\n * @type {WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals>}\n */\nexport const RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for RelativeTimeFormat\n * @type {RelativeTimeFormatStaticInternals}\n */\nexport const RELATIVE_TIME_FORMAT_STATIC_INTERNALS: RelativeTimeFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « \"nu\" ».\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [\"nu\"],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @param {RelativeTimeFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T,\n\tvalue: RelativeTimeFormatInstanceInternals[T]\n): void {\n\tlet record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = Object.create(null) as RelativeTimeFormatInstanceInternals;\n\t\tRELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T\n): RelativeTimeFormatInstanceInternals[T] {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of RelativeTimeFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of RelativeTimeFormat exists\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T): boolean {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\n\n/**\n * When the ResolvePlural abstract operation is called with arguments pluralRules (which must be an object initialized as a PluralRules) and n (which must be a Number value), it returns a String value representing the plural form of n according to the effective locale and the options of pluralRules.\n *\n * https://tc39.github.io/ecma402/#sec-resolveplural\n * @param {RelativeTimeFormat} relativeTimeFormat - needed to get internal slots\n * @param {number} n\n */\nexport function resolvePlural(relativeTimeFormat: RelativeTimeFormat, n: number): string {\n\t// Assert: Type(pluralRules) is Object.\n\t// Assert: pluralRules has an [[InitializedPluralRules]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"pluralRules\")) {\n\t\tthrow new TypeError(`Given instance of of Intl.RelativeTimeFormat must have an [[InitializedPluralRules]] internal slot`);\n\t}\n\n\t// Assert: Type(n) is Number.\n\tif (typeof n !== \"number\") {\n\t\tthrow new TypeError(`Argument 'n' must be a number`);\n\t}\n\n\t// If n is not a finite Number, then\n\tif (!isFinite(n)) {\n\t\t// Return \"other\".\n\t\treturn \"other\";\n\t}\n\n\t// Let locale be pluralRules.[[Locale]].\n\t// Let type be pluralRules.[[Type]].\n\tconst pluralRules = getInternalSlot(relativeTimeFormat, \"pluralRules\");\n\n\t// Return ? PluralRuleSelect(locale, type, n, operands).\n\treturn pluralRules.select(n);\n}\n","import {SingularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The MakePartsList abstract operation is called with arguments pattern,\n * a pattern String, unit, a String, and parts, a List of Records representing a formatted Number.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-makepartslist\n * @param {string} pattern\n * @param {SingularRelativeTimeUnit} unit\n * @param {Intl.NumberFormatPart[]} parts\n * @returns {RelativeTimeFormatPart}\n */\nexport function makePartsList(pattern: string, unit: SingularRelativeTimeUnit, parts: Intl.NumberFormatPart[]): RelativeTimeFormatPart[] {\n\t// Let result be a new empty List.\n\tconst result: RelativeTimeFormatPart[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let endIndex be 0.\n\tlet endIndex = 0;\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of elements in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Set endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tendIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is not -1, otherwise the pattern would be malformed.\n\t\tif (endIndex === -1) {\n\t\t\tthrow new RangeError(`The pattern: '${pattern}' is malformed`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst p = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: p is \"0\".\n\t\tif (p !== \"0\") {\n\t\t\tthrow new TypeError(`Expected ${p} to be \"0\"`);\n\t\t}\n\n\t\t// For each part in parts, do\n\t\tfor (const part of parts) {\n\t\t\t// Add new part Record { [[Type]]: part.[[Type]], [[Value]]: part.[[Value]], [[Unit]]: unit } as a new element on the List result.\n\t\t\tif (part.type === \"literal\") {\n\t\t\t\tresult.push({...part, type: part.type});\n\t\t\t} else {\n\t\t\t\tresult.push({...part, unit});\n\t\t\t}\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, exclusive, to position length, exclusive.\n\t\t// CORRECTION: It should actually be from nextIndex, inclusive, to correctly partition text\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {ExtendedSingularRelativeTimeUnit, singularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\nimport {resolvePlural} from \"../resolve-plural/resolve-plural\";\nimport {makePartsList} from \"../make-parts-list/make-parts-list\";\nimport {toString} from \"../../util/to-string\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * When the FormatRelativeTime abstract operation is called with arguments relativeTimeFormat,\n * value, and unit it returns a String value representing value (interpreted as a time value as specified in ES2016, 20.3.1.1)\n * according to the effective locale and the formatting options of relativeTimeFormat.\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @returns {RelativeTimeFormatPart[]}\n */\nexport function partitionRelativeTimePattern(\n\trelativeTimeFormat: RelativeTimeFormat,\n\tvalue: number,\n\tunit: RelativeTimeUnit\n): RelativeTimeFormatPart[] {\n\t// Assert: relativeTimeFormat has an [[InitializedRelativeTimeFormat]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\tthrow new TypeError(`Internal function called on incompatible receiver ${relativeTimeFormat.toString()}`);\n\t}\n\n\t// Assert: Type(value) is Number.\n\tif (typeof value !== \"number\") {\n\t\tthrow new TypeError(`Argument: 'value' must be a number`);\n\t}\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`Argument: 'unit' must be a string`);\n\t}\n\n\t// If value is NaN, +∞, or -∞, throw a RangeError exception.\n\tif (isNaN(value) || value === Infinity || value === -Infinity) {\n\t\tthrow new RangeError(`Value need to be finite number`);\n\t}\n\n\t// Let unit be ? SingularRelativeTimeUnit(unit).\n\tunit = singularRelativeTimeUnit(unit);\n\n\t// Let fields be relativeTimeFormat.[[Fields]].\n\tconst fields = getInternalSlot(relativeTimeFormat, \"fields\");\n\n\t// Let style be relativeTimeFormat.[[Style]].\n\tconst style = getInternalSlot(relativeTimeFormat, \"style\");\n\n\t// If style is equal to \"short\", then let entry be the string-concatenation of unit and \"-short\".\n\t// Else if style is equal to \"narrow\", then let entry be the string-concatenation of unit and \"-narrow\".\n\t// Else let entry be unit.\n\tlet entry =\n\t\tstyle === \"short\"\n\t\t\t? (`${unit}-short` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: style === \"narrow\"\n\t\t\t? (`${unit}-narrow` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: unit;\n\n\t// Let exists be ! HasProperty(fields, entry).\n\tlet exists = entry in fields;\n\n\t// If exists is false, then\n\tif (!exists) {\n\t\t// Let entry be unit.\n\t\tentry = unit;\n\t}\n\n\t// Let patterns be ! Get(fields, entry).\n\tconst patterns = fields[entry];\n\n\t// Make sure that the patterns are defined\n\tif (patterns == null) {\n\t\tthrow new TypeError(`Could not match entry: '${entry}' inside fields for locale: '${getInternalSlot(relativeTimeFormat, \"locale\")}'`);\n\t}\n\n\t// Let numeric be relativeTimeFormat.[[Numeric]].\n\tconst numeric = getInternalSlot(relativeTimeFormat, \"numeric\");\n\n\t// If numeric is equal to \"auto\", then\n\tif (numeric === \"auto\") {\n\t\t// Let exists be ! HasProperty(patterns, ! ToString(value)).\n\t\texists = toString(value) in patterns;\n\n\t\t// If exists is true, then\n\t\tif (exists) {\n\t\t\t// Let result be ! Get(patterns, ! ToString(value)).\n\t\t\tconst result = patterns[toString(value)];\n\n\t\t\t// Return a List containing the Record { [[Type]]: \"literal\", [[Value]]: result }.\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttype: \"literal\",\n\t\t\t\t\tvalue: result\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t}\n\n\t// If value is -0 or if value is less than 0, then let tl be \"past\".\n\t// Else let tl be \"future\".\n\tconst tl = Object.is(value, -0) || value < 0 ? \"past\" : \"future\";\n\n\t// Let po be ! Get(patterns, tl).\n\tconst po = patterns[tl];\n\n\t// Let fv be ! PartitionNumberPattern(relativeTimeFormat.[[NumberFormat]], value).\n\tconst fv = getInternalSlot(relativeTimeFormat, \"numberFormat\").formatToParts(Math.abs(value));\n\n\t// Let pr be ! ResolvePlural(relativeTimeFormat.[[PluralRules]], value).\n\tconst pr = resolvePlural(relativeTimeFormat, value);\n\n\t// Let pattern be ! Get(po, pr).\n\tconst pattern = po[pr];\n\n\t// Return ! MakePartsList(pattern, unit, fv).\n\treturn makePartsList(pattern, unit, fv);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\n\n/**\n * The FormatRelativeTime abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit) and performs the following steps:\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTime\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {string}\n */\nexport function formatRelativeTime(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): string {\n\t// Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit).\n\tconst parts = partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to the string-concatenation of result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\t// Return result.\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The FormatRelativeTimeToParts abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit)\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTimeToParts\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {RelativeTimeFormatPart[]}\n */\nexport function formatRelativeTimeToParts(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\treturn partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n}\n","/**\n * The abstract operation ToNumber converts argument to a value of type Number\n * https://tc39.es/ecma262/#sec-tonumber\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toNumber(argument: unknown): number {\n\treturn Number(argument);\n}\n","import {Locale} from \"../../locale/locale\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelativeTimeFormatOptions} from \"./relative-time-format-options\";\nimport {toObject} from \"../../util/to-object\";\nimport {toString} from \"../../util/to-string\";\nimport {InputLocaleDataEntry} from \"../../locale/locale-data\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {SupportedLocalesOptions} from \"../supported-locales/supported-locales-options\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {formatRelativeTime} from \"../format-relative-time/format-relative-time\";\nimport {getInternalSlot, hasInternalSlot, RELATIVE_TIME_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {IntlPluralRulesConstructor} from \"../../intl-object/intl-object\";\nimport {formatRelativeTimeToParts} from \"../format-relative-time-to-parts/format-relative-time-to-parts\";\nimport {ResolvedRelativeTimeFormatOptions} from \"./resolved-relative-time-format-options\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\nimport {getOption} from \"../../util/get-option\";\nimport {LOCALE_MATCHER} from \"../../locale-matcher/locale-matcher\";\nimport {STYLE} from \"../../style/style\";\nimport {NUMERIC} from \"../../numeric/numeric\";\nimport {toNumber} from \"../../util/to-number\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The RelativeTimeFormat constructor is the %RelativeTimeFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-intl-relativetimeformat-constructor\n */\nexport class RelativeTimeFormat {\n\t// The spec states that the constructor must have a length of 0 and therefore be parameter-less\n\tconstructor() {\n\t\tconst locales = arguments[0] as Locale | Locales | undefined;\n\t\tlet options = arguments[1] as Partial<RelativeTimeFormatOptions>;\n\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.RelativeTimeFormat requires 'new'`);\n\t\t}\n\n\t\t// The following operations comes from the 'InitializeRelativeFormat' abstract operation (http://tc39.github.io/proposal-intl-relative-time/#sec-InitializeRelativeTimeFormat)\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<RelativeTimeFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record (that doesn't derive from Object.prototype).\n\t\tconst opt = Object.create(null) as RelativeTimeFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", «\"lookup\", \"best fit\"»,  \"best fit\").\n\t\tconst matcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\n\t\t// Set opt.[[LocaleMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let localeData be %RelativeTimeFormat%.[[LocaleData]].\n\t\tconst localeData = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %RelativeTimeFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales,\n\t\t\trequestedLocales,\n\t\t\topt,\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.relevantExtensionKeys,\n\t\t\tlocaleData\n\t\t);\n\n\t\t// Let locale be r.[[Locale]].\n\t\tconst locale = r.locale;\n\n\t\t// Set relativeTimeFormat.[[Locale]] to locale.\n\t\tsetInternalSlot(this, \"locale\", locale);\n\n\t\t// Set relativeTimeFormat.[[NumberingSystem]] to r_.[[nu]].\n\t\tsetInternalSlot(this, \"numberingSystem\", r.nu);\n\n\t\t// Let dataLocale be r.[[DataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let s be ? GetOption(options, \"style\", \"string\", «\"long\", \"short\", \"narrow\"», \"long\").\n\t\tconst s = getOption(options, \"style\", \"string\", STYLE, \"long\");\n\n\t\t// Set relativeTimeFormat.[[Style]] to s.\n\t\tsetInternalSlot(this, \"style\", s);\n\n\t\t// Let numeric be ? GetOption(options, \"numeric\", \"string\", «\"always\", \"auto\"», \"always\").\n\t\tconst numeric = getOption(options, \"numeric\", \"string\", NUMERIC, \"always\");\n\n\t\t// Set relativeTimeFormat.[[Numeric]] to numeric.\n\t\tsetInternalSlot(this, \"numeric\", numeric);\n\n\t\t// Let fields be ! Get(localeData, dataLocale).\n\t\tconst fields = localeData[dataLocale];\n\n\t\t// Assert: fields is an object (see 1.3.3).\n\t\tif (!(fields instanceof Object)) {\n\t\t\tthrow new TypeError(`Expected the LocaleDataEntry for locale: '${dataLocale}' to be an Object`);\n\t\t}\n\n\t\t// Set relativeTimeFormat.[[Fields]] to fields.\n\t\tsetInternalSlot(this, \"fields\", fields);\n\n\t\t// Let relativeTimeFormat.[[NumberFormat]] be ! Construct(%NumberFormat%, « locale »).\n\t\tsetInternalSlot(this, \"numberFormat\", new Intl.NumberFormat(locale));\n\n\t\t// Let relativeTimeFormat.[[PluralRules]] be ! Construct(%PluralRules%, « locale »).\n\t\t// tslint:disable-next-line:no-any\n\t\tsetInternalSlot(\n\t\t\tthis,\n\t\t\t\"pluralRules\",\n\t\t\tnew ((Intl as unknown) as {\n\t\t\t\tPluralRules: IntlPluralRulesConstructor;\n\t\t\t}).PluralRules(locale)\n\t\t);\n\n\t\t// Intl.RelativeTimeFormat instances have an [[InitializedRelativeTimeFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedRelativeTimeFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @return {Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales): Locales {\n\t\t// The spec states that the 'length' value of supportedLocalesOf must be equal to 1,\n\t\t// so we have to pull the options argument out of the method signature\n\t\tconst options = arguments[1] as SupportedLocalesOptions | undefined;\n\n\t\t// Let availableLocales be %RelativeTimeFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Method that formats a value and unit according to the locale and formatting options of this Intl.RelativeTimeFormat object.\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {string}\n\t */\n\tpublic format(value: number, unit: RelativeTimeUnit): string {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTime(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTime(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * A version of the 'format' method that returns an array of objects which represent \"parts\" of the object,\n\t * separating the formatted number into its constituent parts and separating it from other surrounding text\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {RelativeTimeFormatPart[]}\n\t */\n\tpublic formatToParts(value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTimeToParts(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTimeToParts(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedRelativeTimeFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedRelativeTimeFormatOptions {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\t\tconst numeric = getInternalSlot(this, \"numeric\");\n\t\tconst numberingSystem = getInternalSlot(this, \"numberingSystem\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\tstyle,\n\t\t\tnumeric,\n\t\t\tnumberingSystem\n\t\t};\n\t}\n}\n\n/**\n * The initial value of the @@toStringTag property is the string value \"Intl.RelativeTimeFormat\".\n * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n * @type {string}\n */\nObject.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {\n\twritable: false,\n\tenumerable: false,\n\tvalue: \"Intl.RelativeTimeFormat\",\n\tconfigurable: true\n});\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format/relative-time-format\";\n\n/**\n * Patches Intl with Intl.RelativeTimeFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(\n\t\t\t`Could not define Intl.RelativeTimeFormat: Expected 'Intl' to exist. Remember to include polyfills for Intl.NumberFormat, Intl.getCanonicalLocales, and Intl.PluralRules before applying this polyfill`\n\t\t);\n\t}\n\tIntl.RelativeTimeFormat = RelativeTimeFormat;\n}\n","import {SUPPORTS_RELATIVE_TIME_FORMAT} from \"./support/supports-relative-time-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_RELATIVE_TIME_FORMAT) {\n\tpatch();\n}\n"],"names":[],"mappings":"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"}