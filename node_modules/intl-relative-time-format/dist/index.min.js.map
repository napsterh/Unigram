{"version":3,"file":"index.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../src/unit/singular-relative-time-unit.ts","../node_modules/@babel/runtime/helpers/esm/typeof.js","../src/util/to-object.ts","../src/util/to-string.ts","../src/relative-time-format/unicode-extension/unicode-extension.ts","../src/relative-time-format/matcher/best-available-locale/best-available-locale.ts","../src/relative-time-format/default-locale/get-default-locale.ts","../src/relative-time-format/matcher/lookup-matcher/lookup-matcher.ts","../src/relative-time-format/matcher/best-fit-matcher/best-fit-matcher.ts","../src/assert/is-record.ts","../src/assert/is-list.ts","../src/util/same-value.ts","../src/relative-time-format/resolve-locale/resolve-locale.ts","../src/relative-time-format/supported-locales/lookup-supported-locales.ts","../src/relative-time-format/supported-locales/best-fit-supported-locales.ts","../src/util/is-property-key.ts","../src/util/get.ts","../src/util/to-boolean.ts","../src/util/get-option.ts","../src/relative-time-format/supported-locales/supported-locales.ts","../src/relative-time-format/internal-slot/internal-slot.ts","../src/relative-time-format/resolve-plural/resolve-plural.ts","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/relative-time-format/make-parts-list/make-parts-list.ts","../src/relative-time-format/partition-relative-time-pattern/partition-relative-time-pattern.ts","../src/relative-time-format/format-relative-time/format-relative-time.ts","../src/relative-time-format/format-relative-time-to-parts/format-relative-time-to-parts.ts","../src/util/to-number.ts","../src/support/supports-relative-time-format.ts","../src/locale-matcher/locale-matcher.ts","../src/style/style.ts","../src/numeric/numeric.ts","../src/relative-time-format/relative-time-format/relative-time-format.ts","../src/index.ts","../src/patch/patch.ts"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import {RelativeTimeUnit} from \"./relative-time-unit\";\n\nexport type SingularRelativeTimeUnit = \"second\" | \"minute\" | \"hour\" | \"day\" | \"week\" | \"month\" | \"quarter\" | \"year\";\n\nexport type ExtendedSingularRelativeTimeUnit =\n\t| SingularRelativeTimeUnit\n\t| \"second-narrow\"\n\t| \"second-short\"\n\t| \"minute-narrow\"\n\t| \"minute-short\"\n\t| \"hour-narrow\"\n\t| \"hour-short\"\n\t| \"day-narrow\"\n\t| \"day-short\"\n\t| \"week-narrow\"\n\t| \"week-short\"\n\t| \"month-narrow\"\n\t| \"month-short\"\n\t| \"quarter-narrow\"\n\t| \"quarter-short\"\n\t| \"year-narrow\"\n\t| \"year-short\";\n\nconst VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES: SingularRelativeTimeUnit[] = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"];\n\nexport const VALID_EXTENDED_SINGULAR_RELATIVE_TIME_UNIT_VALUES: ExtendedSingularRelativeTimeUnit[] = [\n\t...VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES,\n\t\"second-narrow\",\n\t\"second-short\",\n\t\"minute-narrow\",\n\t\"minute-short\",\n\t\"hour-narrow\",\n\t\"hour-short\",\n\t\"day-narrow\",\n\t\"day-short\",\n\t\"week-narrow\",\n\t\"week-short\",\n\t\"month-narrow\",\n\t\"month-short\",\n\t\"quarter-narrow\",\n\t\"quarter-short\",\n\t\"year-narrow\",\n\t\"year-short\"\n];\n\n/**\n * Sanitizes a RelativeTimeUnit into a SingularRelativeTimeUnit\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-singularrelativetimeunit\n * @param {RelativeTimeUnit} unit\n * @return {SingularRelativeTimeUnit}\n */\nexport function singularRelativeTimeUnit(unit: RelativeTimeUnit): SingularRelativeTimeUnit {\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`unit: '${unit}' must be a string`);\n\t}\n\n\t// If unit is \"seconds\", return \"second\".\n\tif (unit === \"seconds\") return \"second\";\n\n\t// If unit is \"minutes\", return \"minute\".\n\tif (unit === \"minutes\") return \"minute\";\n\n\t// If unit is \"hours\", return \"hour\".\n\tif (unit === \"hours\") return \"hour\";\n\n\t// If unit is \"days\", return \"day\".\n\tif (unit === \"days\") return \"day\";\n\n\t// If unit is \"weeks\", return \"week\".\n\tif (unit === \"weeks\") return \"week\";\n\n\t// If unit is \"months\", return \"month\".\n\tif (unit === \"months\") return \"month\";\n\n\t// If unit is \"quarters\", return \"quarter\".\n\tif (unit === \"quarters\") return \"quarter\";\n\n\t// If unit is \"years\", return \"year\".\n\tif (unit === \"years\") return \"year\";\n\n\t// If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", or \"year\", throw a RangeError exception.\n\tif (!VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.some(validUnit => validUnit === unit)) {\n\t\tthrow new RangeError(`Unit: '${unit}' must be one of: ${VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.map(val => `\"${val}\"`).join(\", \")}`);\n\t}\n\n\t// Return unit.\n\treturn unit;\n}\n","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @return {T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","/**\n * The abstract operation ToString converts argument to a value of type String\n * https://tc39.es/ecma262/#sec-tostring\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toString(argument: unknown): string {\n\treturn argument + \"\";\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @return {string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n\n/**\n * The abstract operation UnicodeExtensionValue is called with extension, which must be a Unicode locale extension sequence,\n * and String key. This operation returns the type subtags for key.\n * @param {string} extension\n * @param {string} key\n * @returns {string?}\n */\nexport function unicodeExtensionValue(extension: string, key: string): string | undefined {\n\t// Assert: The number of elements in key is 2.\n\tif (key.length !== 2) {\n\t\tthrow new TypeError(`Could not get UnicodeExtensionValue: The given key: '${key}' must have a length of 2`);\n\t}\n\n\t// Let size be the number of elements in extension.\n\tconst size = key.length;\n\n\t// Let searchValue be the concatenation of \"-\", key, and \"-\".\n\tlet searchValue = `-${key}-`;\n\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tlet pos = String.prototype.indexOf.call(extension, searchValue);\n\n\t// If pos ≠ -1, then\n\tif (pos !== -1) {\n\t\t// Let start be pos + 4.\n\t\tconst start = pos + 4;\n\t\t// Let end be start.\n\t\tlet end = start;\n\t\t// Let k be start.\n\t\tlet k = start;\n\t\t// Let done be false.\n\t\tlet done = false;\n\n\t\t// Repeat, while done is false\n\t\twhile (!done) {\n\t\t\t// Let e be Call(%StringProto_indexOf%, extension, « \"-\", k »).\n\t\t\tconst e = String.prototype.indexOf.call(extension, \"-\", k);\n\n\t\t\t// If e = -1, let len be size - k; else let len be e - k.\n\t\t\tconst len = e === -1 ? size - k : e - k;\n\n\t\t\t// If len = 2, then\n\t\t\tif (len === 2) {\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else if e = -1, then\n\t\t\telse if (e === -1) {\n\t\t\t\t// Let end be size.\n\t\t\t\tend = size;\n\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else,\n\t\t\telse {\n\t\t\t\t// Let end be e.\n\t\t\t\tend = e;\n\n\t\t\t\t// Let k be e + 1.\n\t\t\t\tk = e + 1;\n\t\t\t}\n\t\t}\n\t\t// Return the String value equal to the substring of extension consisting of\n\t\t// the code units at indices start (inclusive) through end (exclusive).\n\t\treturn extension.slice(start, end);\n\t}\n\n\t// Let searchValue be the concatenation of \"-\" and key.\n\tsearchValue = `-${key}`;\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tpos = String.prototype.indexOf.call(extension, searchValue);\n\t// If pos ≠ -1 and pos + 3 = size, then\n\tif (pos !== -1 && pos + 3 === size) {\n\t\t// Return the empty String.\n\t\treturn \"\";\n\t}\n\n\t// Return undefined.\n\treturn undefined;\n}\n","import {Locales} from \"../../../locale/locales\";\nimport {Locale} from \"../../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @return {string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {Locale} from \"../../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @return {Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @return {Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = {} as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * RelativeTimeFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","/**\n * The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevaluenonnumber\n * @param {Exclude<*, number>} x\n * @param {Exclude<*, number>} y\n * @return {boolean}\n */\nfunction sameValueNonNumber(x: Exclude<unknown, number>, y: Exclude<unknown, number>): boolean {\n\t// Assert: Type(x) is not Number.\n\tif (typeof x === \"number\") {\n\t\tthrow new TypeError(`First argument 'x' must not be a number`);\n\t}\n\n\t// Assert: Type(x) is the same as Type(y).\n\tif (typeof x !== typeof y) {\n\t\tthrow new TypeError(`The given arguments must have the same type`);\n\t}\n\n\t// If Type(x) is Undefined, return true.\n\tif (x === undefined) return true;\n\n\t// If Type(x) is Null, return true.\n\tif (x === null) return true;\n\n\t// If Type(x) is String, then\n\tif (typeof x === \"string\") {\n\t\t// If x and y are exactly the same sequence of code units\n\t\t// (same length and same code units at corresponding indices), return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Boolean, then\n\tif (typeof x === \"boolean\") {\n\t\t// If x and y are both true or both false, return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Symbol, then\n\tif (typeof x === \"symbol\") {\n\t\t// If x and y are both the same Symbol value, return true; otherwise, return false.\n\t\treturn x.valueOf() === (y as symbol).valueOf();\n\t}\n\n\t// If x and y are the same Object value, return true. Otherwise, return false.\n\treturn x === y;\n}\n\n/**\n * The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevalue\n * @param {*} x\n * @param {*} y\n * @return {boolean}\n */\nexport function sameValue(x: unknown, y: unknown): boolean {\n\t// If Type(x) is different from Type(y), return false.\n\tif (typeof x !== typeof y) return false;\n\n\t// If Type(x) is Number, then\n\tif (typeof x === \"number\") {\n\t\t// If x is NaN and y is NaN, return true.\n\t\tif (isNaN(x) && isNaN(y as number)) return true;\n\n\t\t// If x is +0 and y is -0, return false.\n\t\tif (Object.is(x, 0) && Object.is(y, -0)) return false;\n\n\t\t// If x is the same Number value as y, return true.\n\t\tif (x === y) return true;\n\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// Return SameValueNonNumber(x, y).\n\treturn sameValueNonNumber(x, y);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {isRecord} from \"../../assert/is-record\";\nimport {isList} from \"../../assert/is-list\";\nimport {unicodeExtensionValue} from \"../unicode-extension/unicode-extension\";\nimport {sameValue} from \"../../util/same-value\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelevantExtensionKey} from \"../../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} relevantExtensionKeys\n * @param {LocaleData} localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\trelevantExtensionKeys: RelevantExtensionKey[],\n\tlocaleData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = {} as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tlet supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\tfor (const key of relevantExtensionKeys) {\n\t\t// Let foundLocaleData be localeData.[[<foundLocale>]].\n\t\tconst foundLocaleData = localeData[foundLocale];\n\n\t\t// Assert: Type(foundLocaleData) is Record.\n\t\tif (!isRecord(foundLocaleData)) {\n\t\t\tthrow new TypeError(`LocaleData for locale: '${foundLocale}' must be an object`);\n\t\t}\n\n\t\t// Let keyLocaleData be foundLocaleData.[[<key>]].\n\t\tconst keyLocaleData = foundLocaleData[key];\n\n\t\t// Assert: Type(keyLocaleData) is List.\n\t\tif (!isList(keyLocaleData)) {\n\t\t\tthrow new TypeError(`key: '${key}' in LocaleData for locale: '${foundLocale}' must be indexable`);\n\t\t}\n\n\t\t// Let value be keyLocaleData[0].\n\t\tlet value = keyLocaleData[0];\n\n\t\t// Assert: Type(value) is either String or Null.\n\t\tif (typeof value !== \"string\" && value !== null) {\n\t\t\tthrow new TypeError(`value: '${value}' for key: '${key}' in LocaleData for locale: '${foundLocale}' must be a string or null`);\n\t\t}\n\n\t\t// Let supportedExtensionAddition be \"\".\n\t\tlet supportedExtensionAddition = \"\";\n\n\t\t// If r has an [[extension]] field, then\n\t\tif (\"extension\" in r) {\n\t\t\t// Let requestedValue be UnicodeExtensionValue(r.[[extension]], key).\n\t\t\tconst requestedValue = unicodeExtensionValue(r.extension!, key);\n\n\t\t\t// If requestedValue is not undefined, then\n\t\t\tif (requestedValue !== undefined) {\n\t\t\t\t// If requestedValue is not the empty String, then\n\t\t\t\tif (requestedValue !== \"\") {\n\t\t\t\t\t// If keyLocaleData contains requestedValue, then\n\t\t\t\t\tif (keyLocaleData.includes(requestedValue)) {\n\t\t\t\t\t\t// Let value be requestedValue.\n\t\t\t\t\t\tvalue = requestedValue;\n\n\t\t\t\t\t\t// Let supportedExtensionAddition be the concatenation of \"-\", key, \"-\", and value.\n\t\t\t\t\t\tsupportedExtensionAddition = `-${key}-${value}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Else if keyLocaleData contains \"true\", then\n\t\t\t\telse if (keyLocaleData.includes(\"true\")) {\n\t\t\t\t\t// Let value be \"true\".\n\t\t\t\t\tvalue = \"true\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If options has a field [[<key>]], then\n\t\tif (\"key\" in options) {\n\t\t\t// Let optionsValue be options.[[<key>]].\n\t\t\tconst optionsValue = options.key;\n\n\t\t\t// Assert: Type(optionsValue) is either String, Undefined, or Null.\n\t\t\tif (typeof optionsValue !== \"string\" && optionsValue != null) {\n\t\t\t\tthrow new TypeError(`options value: '${optionsValue}' must be a string, undefined, or null`);\n\t\t\t}\n\n\t\t\t// If keyLocaleData contains optionsValue, then\n\t\t\tif (optionsValue !== undefined && keyLocaleData.includes(optionsValue)) {\n\t\t\t\t// If SameValue(optionsValue, value) is false, then\n\t\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\t\tif (!sameValue(optionsValue, value)) {\n\t\t\t\t\t// Let value be optionsValue.\n\t\t\t\t\tvalue = optionsValue;\n\t\t\t\t\t// Let supportedExtensionAddition be \"\".\n\t\t\t\t\tsupportedExtensionAddition = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set result.[[<key>]] to value.\n\t\tresult[key] = value;\n\n\t\t// Append supportedExtensionAddition to supportedExtension.\n\t\tsupportedExtension += supportedExtensionAddition;\n\t}\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","/**\n * The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.\n * https://tc39.es/ecma262/#sec-ispropertykey\n * @param {*} argument\n * @returns {boolean}\n */\nexport function isPropertyKey(argument: unknown): argument is PropertyKey {\n\t// If Type(argument) is String, return true.\n\tif (typeof argument === \"string\") return true;\n\t// If Type(argument) is Symbol, return true.\n\tif (typeof argument === \"symbol\") return true;\n\t// Return false.\n\treturn false;\n}\n","import {isPropertyKey} from \"./is-property-key\";\n\n/**\n * The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key.\n * https://tc39.es/ecma262/#sec-get-o-p\n * @param {O} o\n * @param {P} p\n * @returns {O[P]}\n */\nexport function get<O extends object, P extends keyof O>(o: O, p: P): O[P] {\n\t// Assert: Type(O) is Object.\n\tif (typeof o !== \"object\") {\n\t\tthrow new TypeError(`Given argument ${o} must be of type Object`);\n\t}\n\n\t// Assert: IsPropertyKey(P) is true.\n\tif (!isPropertyKey(p)) {\n\t\tthrow new TypeError(`Given argument ${p} must be a PropertyKey`);\n\t}\n\treturn o[p];\n}\n","/**\n * The abstract operation ToBoolean converts argument to a value of type Boolean\n * https://tc39.es/ecma262/#sec-toboolean\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toBoolean(argument: unknown): boolean {\n\treturn Boolean(argument);\n}\n","import {get} from \"./get\";\nimport {toBoolean} from \"./to-boolean\";\nimport {toString} from \"./to-string\";\nimport {ElementOf} from \"./element-of\";\n\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param {Options} options\n * @param {Property} property\n * @param {Type} type\n * @param {Values} values\n * @param {Fallback} fallback\n * @returns {Return}\n */\nexport function getOption<\n\tOptions extends object,\n\tProperty extends keyof Options,\n\tType extends Options[Property] extends (string | (string | undefined)) ? \"string\" : \"boolean\",\n\tValues extends Options[Property] extends (string | (string | undefined)) ? readonly string[] : readonly boolean[],\n\tFallback extends ElementOf<Values>,\n\tReturn extends ElementOf<Values>\n>(options: Options, property: Property, type: Type, values: Values, fallback: Fallback): Return {\n\t// Let value be ? Get(options, property).\n\tlet value = get(options, property);\n\t// If value is not undefined, then\n\tif (value !== undefined) {\n\t\t// Assert: type is \"boolean\" or \"string\".\n\t\tif (type !== \"boolean\" && type !== \"string\") {\n\t\t\tthrow new TypeError(`Expected type ${type} to be 'boolean' or 'string`);\n\t\t}\n\n\t\t// If type is \"boolean\", then\n\t\tif (type === \"boolean\") {\n\t\t\t// Let value be ToBoolean(value).\n\t\t\tvalue = (toBoolean(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If type is \"string\", then\n\t\tif (type === \"string\") {\n\t\t\t// Let value be ? ToString(value).\n\t\t\tvalue = (toString(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If values is not undefined, then\n\t\tif (values !== undefined) {\n\t\t\t// If values does not contain an element equal to value, throw a RangeError exception.\n\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\tif (!values.includes(value as never)) {\n\t\t\t\tthrow new RangeError(`Value ${value} out of range for options property ${property}`);\n\t\t\t}\n\t\t}\n\n\t\t// Return value.\n\t\treturn (value as unknown) as Return;\n\t}\n\n\t// Else, return fallback.\n\telse {\n\t\treturn (fallback as unknown) as Return;\n\t}\n}\n","import {Locales} from \"../../locale/locales\";\nimport {toObject} from \"../../util/to-object\";\nimport {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\nimport {LOCALE_MATCHER, LocaleMatcher} from \"../../locale-matcher/locale-matcher\";\nimport {getOption} from \"../../util/get-option\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @return {Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\tlet matcher: LocaleMatcher;\n\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\n\t\tmatcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\t}\n\n\t// Else, let matcher be \"best fit\".\n\telse {\n\t\tmatcher = \"best fit\";\n\t}\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\"\n\t\t? bestFitSupportedLocales(availableLocales, requestedLocales)\n\t\t: lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeFormatInstanceInternals} from \"./relative-time-format-instance-internals\";\nimport {RelativeTimeFormatStaticInternals} from \"./relative-time-format-static-internals\";\n\n/**\n * A WeakMap between RelativeTimeFormat instances and their internal slot members\n * @type {WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals>}\n */\nexport const RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for RelativeTimeFormat\n * @type {RelativeTimeFormatStaticInternals}\n */\nexport const RELATIVE_TIME_FORMAT_STATIC_INTERNALS: RelativeTimeFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « \"nu\" ».\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [\"nu\"],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @param {RelativeTimeFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T,\n\tvalue: RelativeTimeFormatInstanceInternals[T]\n): void {\n\tlet record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = Object.create(null) as RelativeTimeFormatInstanceInternals;\n\t\tRELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T\n): RelativeTimeFormatInstanceInternals[T] {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of RelativeTimeFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of RelativeTimeFormat exists\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T): boolean {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\n\n/**\n * When the ResolvePlural abstract operation is called with arguments pluralRules (which must be an object initialized as a PluralRules) and n (which must be a Number value), it returns a String value representing the plural form of n according to the effective locale and the options of pluralRules.\n *\n * https://tc39.github.io/ecma402/#sec-resolveplural\n * @param {RelativeTimeFormat} relativeTimeFormat - needed to get internal slots\n * @param {number} n\n */\nexport function resolvePlural(relativeTimeFormat: RelativeTimeFormat, n: number): string {\n\t// Assert: Type(pluralRules) is Object.\n\t// Assert: pluralRules has an [[InitializedPluralRules]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"pluralRules\")) {\n\t\tthrow new TypeError(`Given instance of of Intl.RelativeTimeFormat must have an [[InitializedPluralRules]] internal slot`);\n\t}\n\n\t// Assert: Type(n) is Number.\n\tif (typeof n !== \"number\") {\n\t\tthrow new TypeError(`Argument 'n' must be a number`);\n\t}\n\n\t// If n is not a finite Number, then\n\tif (!isFinite(n)) {\n\t\t// Return \"other\".\n\t\treturn \"other\";\n\t}\n\n\t// Let locale be pluralRules.[[Locale]].\n\t// Let type be pluralRules.[[Type]].\n\tconst pluralRules = getInternalSlot(relativeTimeFormat, \"pluralRules\");\n\n\t// Return ? PluralRuleSelect(locale, type, n, operands).\n\treturn pluralRules.select(n);\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (i % 2) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));\n    }\n  }\n\n  return target;\n}","import {SingularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The MakePartsList abstract operation is called with arguments pattern,\n * a pattern String, unit, a String, and parts, a List of Records representing a formatted Number.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-makepartslist\n * @param {string} pattern\n * @param {SingularRelativeTimeUnit} unit\n * @param {Intl.NumberFormatPart[]} parts\n * @returns {RelativeTimeFormatPart}\n */\nexport function makePartsList(pattern: string, unit: SingularRelativeTimeUnit, parts: Intl.NumberFormatPart[]): RelativeTimeFormatPart[] {\n\t// Let result be a new empty List.\n\tconst result: RelativeTimeFormatPart[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let endIndex be 0.\n\tlet endIndex = 0;\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of elements in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Set endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tendIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is not -1, otherwise the pattern would be malformed.\n\t\tif (endIndex === -1) {\n\t\t\tthrow new RangeError(`The pattern: '${pattern}' is malformed`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst p = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: p is \"0\".\n\t\tif (p !== \"0\") {\n\t\t\tthrow new TypeError(`Expected ${p} to be \"0\"`);\n\t\t}\n\n\t\t// For each part in parts, do\n\t\tfor (const part of parts) {\n\t\t\t// Add new part Record { [[Type]]: part.[[Type]], [[Value]]: part.[[Value]], [[Unit]]: unit } as a new element on the List result.\n\t\t\tif (part.type === \"literal\") {\n\t\t\t\tresult.push({...part, type: part.type});\n\t\t\t} else {\n\t\t\t\tresult.push({...part, unit});\n\t\t\t}\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, exclusive, to position length, exclusive.\n\t\t// CORRECTION: It should actually be from nextIndex, inclusive, to correctly partition text\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {ExtendedSingularRelativeTimeUnit, singularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\nimport {resolvePlural} from \"../resolve-plural/resolve-plural\";\nimport {makePartsList} from \"../make-parts-list/make-parts-list\";\nimport {toString} from \"../../util/to-string\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * When the FormatRelativeTime abstract operation is called with arguments relativeTimeFormat,\n * value, and unit it returns a String value representing value (interpreted as a time value as specified in ES2016, 20.3.1.1)\n * according to the effective locale and the formatting options of relativeTimeFormat.\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @returns {RelativeTimeFormatPart[]}\n */\nexport function partitionRelativeTimePattern(\n\trelativeTimeFormat: RelativeTimeFormat,\n\tvalue: number,\n\tunit: RelativeTimeUnit\n): RelativeTimeFormatPart[] {\n\t// Assert: relativeTimeFormat has an [[InitializedRelativeTimeFormat]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\tthrow new TypeError(`Internal function called on incompatible receiver ${relativeTimeFormat.toString()}`);\n\t}\n\n\t// Assert: Type(value) is Number.\n\tif (typeof value !== \"number\") {\n\t\tthrow new TypeError(`Argument: 'value' must be a number`);\n\t}\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`Argument: 'unit' must be a string`);\n\t}\n\n\t// If value is NaN, +∞, or -∞, throw a RangeError exception.\n\tif (isNaN(value) || value === Infinity || value === -Infinity) {\n\t\tthrow new RangeError(`Value need to be finite number`);\n\t}\n\n\t// Let unit be ? SingularRelativeTimeUnit(unit).\n\tunit = singularRelativeTimeUnit(unit);\n\n\t// Let fields be relativeTimeFormat.[[Fields]].\n\tconst fields = getInternalSlot(relativeTimeFormat, \"fields\");\n\n\t// Let style be relativeTimeFormat.[[Style]].\n\tconst style = getInternalSlot(relativeTimeFormat, \"style\");\n\n\t// If style is equal to \"short\", then let entry be the string-concatenation of unit and \"-short\".\n\t// Else if style is equal to \"narrow\", then let entry be the string-concatenation of unit and \"-narrow\".\n\t// Else let entry be unit.\n\tlet entry =\n\t\tstyle === \"short\"\n\t\t\t? (`${unit}-short` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: style === \"narrow\"\n\t\t\t? (`${unit}-narrow` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: unit;\n\n\t// Let exists be ! HasProperty(fields, entry).\n\tlet exists = entry in fields;\n\n\t// If exists is false, then\n\tif (!exists) {\n\t\t// Let entry be unit.\n\t\tentry = unit;\n\t}\n\n\t// Let patterns be ! Get(fields, entry).\n\tconst patterns = fields[entry];\n\n\t// Make sure that the patterns are defined\n\tif (patterns == null) {\n\t\tthrow new TypeError(`Could not match entry: '${entry}' inside fields for locale: '${getInternalSlot(relativeTimeFormat, \"locale\")}'`);\n\t}\n\n\t// Let numeric be relativeTimeFormat.[[Numeric]].\n\tconst numeric = getInternalSlot(relativeTimeFormat, \"numeric\");\n\n\t// If numeric is equal to \"auto\", then\n\tif (numeric === \"auto\") {\n\t\t// Let exists be ! HasProperty(patterns, ! ToString(value)).\n\t\texists = toString(value) in patterns;\n\n\t\t// If exists is true, then\n\t\tif (exists) {\n\t\t\t// Let result be ! Get(patterns, ! ToString(value)).\n\t\t\tconst result = patterns[toString(value)];\n\n\t\t\t// Return a List containing the Record { [[Type]]: \"literal\", [[Value]]: result }.\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttype: \"literal\",\n\t\t\t\t\tvalue: result\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t}\n\n\t// If value is -0 or if value is less than 0, then let tl be \"past\".\n\t// Else let tl be \"future\".\n\tconst tl = Object.is(value, -0) || value < 0 ? \"past\" : \"future\";\n\n\t// Let po be ! Get(patterns, tl).\n\tconst po = patterns[tl];\n\n\t// Let fv be ! PartitionNumberPattern(relativeTimeFormat.[[NumberFormat]], value).\n\tconst fv = getInternalSlot(relativeTimeFormat, \"numberFormat\").formatToParts(Math.abs(value));\n\n\t// Let pr be ! ResolvePlural(relativeTimeFormat.[[PluralRules]], value).\n\tconst pr = resolvePlural(relativeTimeFormat, value);\n\n\t// Let pattern be ! Get(po, pr).\n\tconst pattern = po[pr];\n\n\t// Return ! MakePartsList(pattern, unit, fv).\n\treturn makePartsList(pattern, unit, fv);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\n\n/**\n * The FormatRelativeTime abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit) and performs the following steps:\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTime\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {string}\n */\nexport function formatRelativeTime(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): string {\n\t// Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit).\n\tconst parts = partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to the string-concatenation of result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\t// Return result.\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The FormatRelativeTimeToParts abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit)\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTimeToParts\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {RelativeTimeFormatPart[]}\n */\nexport function formatRelativeTimeToParts(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\treturn partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n}\n","/**\n * The abstract operation ToNumber converts argument to a value of type Number\n * https://tc39.es/ecma262/#sec-tonumber\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toNumber(argument: unknown): number {\n\treturn Number(argument);\n}\n","export const SUPPORTS_RELATIVE_TIME_FORMAT = \"RelativeTimeFormat\" in Intl;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const LOCALE_MATCHER = [\"lookup\", \"best fit\"] as const;\n\nexport type LocaleMatcher = ElementOf<typeof LOCALE_MATCHER>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const STYLE = [\"long\", \"short\", \"narrow\"] as const;\n\nexport type Style = ElementOf<typeof STYLE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const NUMERIC = [\"always\", \"auto\"] as const;\n\nexport type Numeric = ElementOf<typeof NUMERIC>;\n","import {Locale} from \"../../locale/locale\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelativeTimeFormatOptions} from \"./relative-time-format-options\";\nimport {toObject} from \"../../util/to-object\";\nimport {toString} from \"../../util/to-string\";\nimport {InputLocaleDataEntry} from \"../../locale/locale-data\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {SupportedLocalesOptions} from \"../supported-locales/supported-locales-options\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {formatRelativeTime} from \"../format-relative-time/format-relative-time\";\nimport {getInternalSlot, hasInternalSlot, RELATIVE_TIME_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {IntlPluralRulesConstructor} from \"../../intl-object/intl-object\";\nimport {formatRelativeTimeToParts} from \"../format-relative-time-to-parts/format-relative-time-to-parts\";\nimport {ResolvedRelativeTimeFormatOptions} from \"./resolved-relative-time-format-options\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\nimport {getOption} from \"../../util/get-option\";\nimport {LOCALE_MATCHER} from \"../../locale-matcher/locale-matcher\";\nimport {STYLE} from \"../../style/style\";\nimport {NUMERIC} from \"../../numeric/numeric\";\nimport {toNumber} from \"../../util/to-number\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The RelativeTimeFormat constructor is the %RelativeTimeFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-intl-relativetimeformat-constructor\n */\nexport class RelativeTimeFormat {\n\t// The spec states that the constructor must have a length of 0 and therefore be parameter-less\n\tconstructor() {\n\t\tconst locales = arguments[0] as Locale | Locales | undefined;\n\t\tlet options = arguments[1] as Partial<RelativeTimeFormatOptions>;\n\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.RelativeTimeFormat requires 'new'`);\n\t\t}\n\n\t\t// The following operations comes from the 'InitializeRelativeFormat' abstract operation (http://tc39.github.io/proposal-intl-relative-time/#sec-InitializeRelativeTimeFormat)\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<RelativeTimeFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record (that doesn't derive from Object.prototype).\n\t\tconst opt = Object.create(null) as RelativeTimeFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", «\"lookup\", \"best fit\"»,  \"best fit\").\n\t\tconst matcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\n\t\t// Set opt.[[LocaleMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let localeData be %RelativeTimeFormat%.[[LocaleData]].\n\t\tconst localeData = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %RelativeTimeFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales,\n\t\t\trequestedLocales,\n\t\t\topt,\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.relevantExtensionKeys,\n\t\t\tlocaleData\n\t\t);\n\n\t\t// Let locale be r.[[Locale]].\n\t\tconst locale = r.locale;\n\n\t\t// Set relativeTimeFormat.[[Locale]] to locale.\n\t\tsetInternalSlot(this, \"locale\", locale);\n\n\t\t// Set relativeTimeFormat.[[NumberingSystem]] to r_.[[nu]].\n\t\tsetInternalSlot(this, \"numberingSystem\", r.nu);\n\n\t\t// Let dataLocale be r.[[DataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let s be ? GetOption(options, \"style\", \"string\", «\"long\", \"short\", \"narrow\"», \"long\").\n\t\tconst s = getOption(options, \"style\", \"string\", STYLE, \"long\");\n\n\t\t// Set relativeTimeFormat.[[Style]] to s.\n\t\tsetInternalSlot(this, \"style\", s);\n\n\t\t// Let numeric be ? GetOption(options, \"numeric\", \"string\", «\"always\", \"auto\"», \"always\").\n\t\tconst numeric = getOption(options, \"numeric\", \"string\", NUMERIC, \"always\");\n\n\t\t// Set relativeTimeFormat.[[Numeric]] to numeric.\n\t\tsetInternalSlot(this, \"numeric\", numeric);\n\n\t\t// Let fields be ! Get(localeData, dataLocale).\n\t\tconst fields = localeData[dataLocale];\n\n\t\t// Assert: fields is an object (see 1.3.3).\n\t\tif (!(fields instanceof Object)) {\n\t\t\tthrow new TypeError(`Expected the LocaleDataEntry for locale: '${dataLocale}' to be an Object`);\n\t\t}\n\n\t\t// Set relativeTimeFormat.[[Fields]] to fields.\n\t\tsetInternalSlot(this, \"fields\", fields);\n\n\t\t// Let relativeTimeFormat.[[NumberFormat]] be ! Construct(%NumberFormat%, « locale »).\n\t\tsetInternalSlot(this, \"numberFormat\", new Intl.NumberFormat(locale));\n\n\t\t// Let relativeTimeFormat.[[PluralRules]] be ! Construct(%PluralRules%, « locale »).\n\t\t// tslint:disable-next-line:no-any\n\t\tsetInternalSlot(\n\t\t\tthis,\n\t\t\t\"pluralRules\",\n\t\t\tnew ((Intl as unknown) as {\n\t\t\t\tPluralRules: IntlPluralRulesConstructor;\n\t\t\t}).PluralRules(locale)\n\t\t);\n\n\t\t// Intl.RelativeTimeFormat instances have an [[InitializedRelativeTimeFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedRelativeTimeFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @return {Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales): Locales {\n\t\t// The spec states that the 'length' value of supportedLocalesOf must be equal to 1,\n\t\t// so we have to pull the options argument out of the method signature\n\t\tconst options = arguments[1] as SupportedLocalesOptions | undefined;\n\n\t\t// Let availableLocales be %RelativeTimeFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Method that formats a value and unit according to the locale and formatting options of this Intl.RelativeTimeFormat object.\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {string}\n\t */\n\tpublic format(value: number, unit: RelativeTimeUnit): string {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTime(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTime(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * A version of the 'format' method that returns an array of objects which represent \"parts\" of the object,\n\t * separating the formatted number into its constituent parts and separating it from other surrounding text\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {RelativeTimeFormatPart[]}\n\t */\n\tpublic formatToParts(value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTimeToParts(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTimeToParts(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedRelativeTimeFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedRelativeTimeFormatOptions {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\t\tconst numeric = getInternalSlot(this, \"numeric\");\n\t\tconst numberingSystem = getInternalSlot(this, \"numberingSystem\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\tstyle,\n\t\t\tnumeric,\n\t\t\tnumberingSystem\n\t\t};\n\t}\n}\n\n/**\n * The initial value of the @@toStringTag property is the string value \"Intl.RelativeTimeFormat\".\n * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n * @type {string}\n */\nObject.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {\n\twritable: false,\n\tenumerable: false,\n\tvalue: \"Intl.RelativeTimeFormat\",\n\tconfigurable: true\n});\n","import {SUPPORTS_RELATIVE_TIME_FORMAT} from \"./support/supports-relative-time-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_RELATIVE_TIME_FORMAT) {\n\tpatch();\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format/relative-time-format\";\n\n/**\n * Patches Intl with Intl.RelativeTimeFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(\n\t\t\t`Could not define Intl.RelativeTimeFormat: Expected 'Intl' to exist. Remember to include polyfills for Intl.NumberFormat, Intl.getCanonicalLocales, and Intl.PluralRules before applying this polyfill`\n\t\t);\n\t}\n\tIntl.RelativeTimeFormat = RelativeTimeFormat;\n}\n"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","i","length","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","singularRelativeTimeUnit","unit","VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES","some","validUnit","RangeError","map","val","join","_typeof2","obj","Symbol","iterator","constructor","_typeof","toObject","argument","Boolean","Number","String","toString","removeUnicodeExtensionSequences","str","replace","UNICODE_EXTENSION_SEQUENCE_REGEXP","unicodeExtensionValue","extension","size","searchValue","pos","indexOf","call","start","end","k","done","e","len","slice","bestAvailableLocale","availableLocales","locale","candidate","includes","lastIndexOf","charAt","setDefaultLocale","_defaultLocale","getDefaultLocale","ensureDefaultLocale","ReferenceError","lookupMatcher","requestedLocales","result","noExtensionsLocale","availableLocale","extensionMatch","match","defLocale","bestFitMatcher","options","isRecord","item","isList","Array","isArray","sameValueNonNumber","x","y","valueOf","sameValue","isNaN","is","resolveLocale","relevantExtensionKeys","localeData","matcher","localeMatcher","r","foundLocale","dataLocale","supportedExtension","foundLocaleData","keyLocaleData","value","supportedExtensionAddition","requestedValue","optionsValue","privateIndex","preExtension","postExtension","Intl","getCanonicalLocales","lookupSupportedLocales","subset","push","bestFitSupportedLocales","isPropertyKey","get","o","p","toBoolean","getOption","property","type","values","fallback","supportedLocales","LOCALE_MATCHER","setInternalSlot","record","RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP","create","set","getInternalSlot","hasInternalSlot","resolvePlural","relativeTimeFormat","n","isFinite","pluralRules","select","_defineProperty","_objectSpread2","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","defineProperties","getOwnPropertyDescriptors","makePartsList","pattern","parts","beginIndex","endIndex","nextIndex","literal","part","_literal","partitionRelativeTimePattern","Infinity","fields","style","entry","exists","patterns","numeric","tl","po","fv","formatToParts","Math","abs","pr","formatRelativeTime","formatRelativeTimeToParts","toNumber","SUPPORTS_RELATIVE_TIME_FORMAT","STYLE","NUMERIC","WeakMap","RELATIVE_TIME_FORMAT_STATIC_INTERNALS","RelativeTimeFormat","locales","opt","nu","s","NumberFormat","PluralRules","numberingSystem","data","defaultLocale","toStringTag"],"mappings":"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"}