{"version":3,"file":"index.js","sources":["../src/support/supports-relative-time-format.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../src/locale-matcher/locale-matcher.ts","../src/style/style.ts","../src/numeric/numeric.ts","../src/unit/singular-relative-time-unit.ts","../node_modules/@babel/runtime/helpers/esm/typeof.js","../src/util/to-object.ts","../src/util/to-string.ts","../src/relative-time-format/unicode-extension/unicode-extension.ts","../src/relative-time-format/matcher/best-available-locale/best-available-locale.ts","../src/relative-time-format/default-locale/get-default-locale.ts","../src/relative-time-format/matcher/lookup-matcher/lookup-matcher.ts","../src/relative-time-format/matcher/best-fit-matcher/best-fit-matcher.ts","../src/assert/is-record.ts","../src/assert/is-list.ts","../src/util/same-value.ts","../src/relative-time-format/resolve-locale/resolve-locale.ts","../src/relative-time-format/supported-locales/lookup-supported-locales.ts","../src/relative-time-format/supported-locales/best-fit-supported-locales.ts","../src/util/is-property-key.ts","../src/util/get.ts","../src/util/to-boolean.ts","../src/util/get-option.ts","../src/relative-time-format/supported-locales/supported-locales.ts","../src/relative-time-format/internal-slot/internal-slot.ts","../src/relative-time-format/resolve-plural/resolve-plural.ts","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/relative-time-format/make-parts-list/make-parts-list.ts","../src/relative-time-format/partition-relative-time-pattern/partition-relative-time-pattern.ts","../src/relative-time-format/format-relative-time/format-relative-time.ts","../src/relative-time-format/format-relative-time-to-parts/format-relative-time-to-parts.ts","../src/util/to-number.ts","../src/relative-time-format/relative-time-format/relative-time-format.ts","../src/patch/patch.ts","../src/index.ts"],"sourcesContent":["export const SUPPORTS_RELATIVE_TIME_FORMAT = \"RelativeTimeFormat\" in Intl;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import {ElementOf} from \"../util/element-of\";\n\nexport const LOCALE_MATCHER = [\"lookup\", \"best fit\"] as const;\n\nexport type LocaleMatcher = ElementOf<typeof LOCALE_MATCHER>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const STYLE = [\"long\", \"short\", \"narrow\"] as const;\n\nexport type Style = ElementOf<typeof STYLE>;\n","import {ElementOf} from \"../util/element-of\";\n\nexport const NUMERIC = [\"always\", \"auto\"] as const;\n\nexport type Numeric = ElementOf<typeof NUMERIC>;\n","import {RelativeTimeUnit} from \"./relative-time-unit\";\n\nexport type SingularRelativeTimeUnit = \"second\" | \"minute\" | \"hour\" | \"day\" | \"week\" | \"month\" | \"quarter\" | \"year\";\n\nexport type ExtendedSingularRelativeTimeUnit =\n\t| SingularRelativeTimeUnit\n\t| \"second-narrow\"\n\t| \"second-short\"\n\t| \"minute-narrow\"\n\t| \"minute-short\"\n\t| \"hour-narrow\"\n\t| \"hour-short\"\n\t| \"day-narrow\"\n\t| \"day-short\"\n\t| \"week-narrow\"\n\t| \"week-short\"\n\t| \"month-narrow\"\n\t| \"month-short\"\n\t| \"quarter-narrow\"\n\t| \"quarter-short\"\n\t| \"year-narrow\"\n\t| \"year-short\";\n\nconst VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES: SingularRelativeTimeUnit[] = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"];\n\nexport const VALID_EXTENDED_SINGULAR_RELATIVE_TIME_UNIT_VALUES: ExtendedSingularRelativeTimeUnit[] = [\n\t...VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES,\n\t\"second-narrow\",\n\t\"second-short\",\n\t\"minute-narrow\",\n\t\"minute-short\",\n\t\"hour-narrow\",\n\t\"hour-short\",\n\t\"day-narrow\",\n\t\"day-short\",\n\t\"week-narrow\",\n\t\"week-short\",\n\t\"month-narrow\",\n\t\"month-short\",\n\t\"quarter-narrow\",\n\t\"quarter-short\",\n\t\"year-narrow\",\n\t\"year-short\"\n];\n\n/**\n * Sanitizes a RelativeTimeUnit into a SingularRelativeTimeUnit\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-singularrelativetimeunit\n * @param {RelativeTimeUnit} unit\n * @return {SingularRelativeTimeUnit}\n */\nexport function singularRelativeTimeUnit(unit: RelativeTimeUnit): SingularRelativeTimeUnit {\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`unit: '${unit}' must be a string`);\n\t}\n\n\t// If unit is \"seconds\", return \"second\".\n\tif (unit === \"seconds\") return \"second\";\n\n\t// If unit is \"minutes\", return \"minute\".\n\tif (unit === \"minutes\") return \"minute\";\n\n\t// If unit is \"hours\", return \"hour\".\n\tif (unit === \"hours\") return \"hour\";\n\n\t// If unit is \"days\", return \"day\".\n\tif (unit === \"days\") return \"day\";\n\n\t// If unit is \"weeks\", return \"week\".\n\tif (unit === \"weeks\") return \"week\";\n\n\t// If unit is \"months\", return \"month\".\n\tif (unit === \"months\") return \"month\";\n\n\t// If unit is \"quarters\", return \"quarter\".\n\tif (unit === \"quarters\") return \"quarter\";\n\n\t// If unit is \"years\", return \"year\".\n\tif (unit === \"years\") return \"year\";\n\n\t// If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", or \"year\", throw a RangeError exception.\n\tif (!VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.some(validUnit => validUnit === unit)) {\n\t\tthrow new RangeError(`Unit: '${unit}' must be one of: ${VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.map(val => `\"${val}\"`).join(\", \")}`);\n\t}\n\n\t// Return unit.\n\treturn unit;\n}\n","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @return {T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","/**\n * The abstract operation ToString converts argument to a value of type String\n * https://tc39.es/ecma262/#sec-tostring\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toString(argument: unknown): string {\n\treturn argument + \"\";\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @return {string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n\n/**\n * The abstract operation UnicodeExtensionValue is called with extension, which must be a Unicode locale extension sequence,\n * and String key. This operation returns the type subtags for key.\n * @param {string} extension\n * @param {string} key\n * @returns {string?}\n */\nexport function unicodeExtensionValue(extension: string, key: string): string | undefined {\n\t// Assert: The number of elements in key is 2.\n\tif (key.length !== 2) {\n\t\tthrow new TypeError(`Could not get UnicodeExtensionValue: The given key: '${key}' must have a length of 2`);\n\t}\n\n\t// Let size be the number of elements in extension.\n\tconst size = key.length;\n\n\t// Let searchValue be the concatenation of \"-\", key, and \"-\".\n\tlet searchValue = `-${key}-`;\n\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tlet pos = String.prototype.indexOf.call(extension, searchValue);\n\n\t// If pos ≠ -1, then\n\tif (pos !== -1) {\n\t\t// Let start be pos + 4.\n\t\tconst start = pos + 4;\n\t\t// Let end be start.\n\t\tlet end = start;\n\t\t// Let k be start.\n\t\tlet k = start;\n\t\t// Let done be false.\n\t\tlet done = false;\n\n\t\t// Repeat, while done is false\n\t\twhile (!done) {\n\t\t\t// Let e be Call(%StringProto_indexOf%, extension, « \"-\", k »).\n\t\t\tconst e = String.prototype.indexOf.call(extension, \"-\", k);\n\n\t\t\t// If e = -1, let len be size - k; else let len be e - k.\n\t\t\tconst len = e === -1 ? size - k : e - k;\n\n\t\t\t// If len = 2, then\n\t\t\tif (len === 2) {\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else if e = -1, then\n\t\t\telse if (e === -1) {\n\t\t\t\t// Let end be size.\n\t\t\t\tend = size;\n\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else,\n\t\t\telse {\n\t\t\t\t// Let end be e.\n\t\t\t\tend = e;\n\n\t\t\t\t// Let k be e + 1.\n\t\t\t\tk = e + 1;\n\t\t\t}\n\t\t}\n\t\t// Return the String value equal to the substring of extension consisting of\n\t\t// the code units at indices start (inclusive) through end (exclusive).\n\t\treturn extension.slice(start, end);\n\t}\n\n\t// Let searchValue be the concatenation of \"-\" and key.\n\tsearchValue = `-${key}`;\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tpos = String.prototype.indexOf.call(extension, searchValue);\n\t// If pos ≠ -1 and pos + 3 = size, then\n\tif (pos !== -1 && pos + 3 === size) {\n\t\t// Return the empty String.\n\t\treturn \"\";\n\t}\n\n\t// Return undefined.\n\treturn undefined;\n}\n","import {Locales} from \"../../../locale/locales\";\nimport {Locale} from \"../../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @return {string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {Locale} from \"../../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @return {Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @return {Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = {} as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * RelativeTimeFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","/**\n * The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevaluenonnumber\n * @param {Exclude<*, number>} x\n * @param {Exclude<*, number>} y\n * @return {boolean}\n */\nfunction sameValueNonNumber(x: Exclude<unknown, number>, y: Exclude<unknown, number>): boolean {\n\t// Assert: Type(x) is not Number.\n\tif (typeof x === \"number\") {\n\t\tthrow new TypeError(`First argument 'x' must not be a number`);\n\t}\n\n\t// Assert: Type(x) is the same as Type(y).\n\tif (typeof x !== typeof y) {\n\t\tthrow new TypeError(`The given arguments must have the same type`);\n\t}\n\n\t// If Type(x) is Undefined, return true.\n\tif (x === undefined) return true;\n\n\t// If Type(x) is Null, return true.\n\tif (x === null) return true;\n\n\t// If Type(x) is String, then\n\tif (typeof x === \"string\") {\n\t\t// If x and y are exactly the same sequence of code units\n\t\t// (same length and same code units at corresponding indices), return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Boolean, then\n\tif (typeof x === \"boolean\") {\n\t\t// If x and y are both true or both false, return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Symbol, then\n\tif (typeof x === \"symbol\") {\n\t\t// If x and y are both the same Symbol value, return true; otherwise, return false.\n\t\treturn x.valueOf() === (y as symbol).valueOf();\n\t}\n\n\t// If x and y are the same Object value, return true. Otherwise, return false.\n\treturn x === y;\n}\n\n/**\n * The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevalue\n * @param {*} x\n * @param {*} y\n * @return {boolean}\n */\nexport function sameValue(x: unknown, y: unknown): boolean {\n\t// If Type(x) is different from Type(y), return false.\n\tif (typeof x !== typeof y) return false;\n\n\t// If Type(x) is Number, then\n\tif (typeof x === \"number\") {\n\t\t// If x is NaN and y is NaN, return true.\n\t\tif (isNaN(x) && isNaN(y as number)) return true;\n\n\t\t// If x is +0 and y is -0, return false.\n\t\tif (Object.is(x, 0) && Object.is(y, -0)) return false;\n\n\t\t// If x is the same Number value as y, return true.\n\t\tif (x === y) return true;\n\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// Return SameValueNonNumber(x, y).\n\treturn sameValueNonNumber(x, y);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {isRecord} from \"../../assert/is-record\";\nimport {isList} from \"../../assert/is-list\";\nimport {unicodeExtensionValue} from \"../unicode-extension/unicode-extension\";\nimport {sameValue} from \"../../util/same-value\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelevantExtensionKey} from \"../../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} relevantExtensionKeys\n * @param {LocaleData} localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\trelevantExtensionKeys: RelevantExtensionKey[],\n\tlocaleData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = {} as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tlet supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\tfor (const key of relevantExtensionKeys) {\n\t\t// Let foundLocaleData be localeData.[[<foundLocale>]].\n\t\tconst foundLocaleData = localeData[foundLocale];\n\n\t\t// Assert: Type(foundLocaleData) is Record.\n\t\tif (!isRecord(foundLocaleData)) {\n\t\t\tthrow new TypeError(`LocaleData for locale: '${foundLocale}' must be an object`);\n\t\t}\n\n\t\t// Let keyLocaleData be foundLocaleData.[[<key>]].\n\t\tconst keyLocaleData = foundLocaleData[key];\n\n\t\t// Assert: Type(keyLocaleData) is List.\n\t\tif (!isList(keyLocaleData)) {\n\t\t\tthrow new TypeError(`key: '${key}' in LocaleData for locale: '${foundLocale}' must be indexable`);\n\t\t}\n\n\t\t// Let value be keyLocaleData[0].\n\t\tlet value = keyLocaleData[0];\n\n\t\t// Assert: Type(value) is either String or Null.\n\t\tif (typeof value !== \"string\" && value !== null) {\n\t\t\tthrow new TypeError(`value: '${value}' for key: '${key}' in LocaleData for locale: '${foundLocale}' must be a string or null`);\n\t\t}\n\n\t\t// Let supportedExtensionAddition be \"\".\n\t\tlet supportedExtensionAddition = \"\";\n\n\t\t// If r has an [[extension]] field, then\n\t\tif (\"extension\" in r) {\n\t\t\t// Let requestedValue be UnicodeExtensionValue(r.[[extension]], key).\n\t\t\tconst requestedValue = unicodeExtensionValue(r.extension!, key);\n\n\t\t\t// If requestedValue is not undefined, then\n\t\t\tif (requestedValue !== undefined) {\n\t\t\t\t// If requestedValue is not the empty String, then\n\t\t\t\tif (requestedValue !== \"\") {\n\t\t\t\t\t// If keyLocaleData contains requestedValue, then\n\t\t\t\t\tif (keyLocaleData.includes(requestedValue)) {\n\t\t\t\t\t\t// Let value be requestedValue.\n\t\t\t\t\t\tvalue = requestedValue;\n\n\t\t\t\t\t\t// Let supportedExtensionAddition be the concatenation of \"-\", key, \"-\", and value.\n\t\t\t\t\t\tsupportedExtensionAddition = `-${key}-${value}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Else if keyLocaleData contains \"true\", then\n\t\t\t\telse if (keyLocaleData.includes(\"true\")) {\n\t\t\t\t\t// Let value be \"true\".\n\t\t\t\t\tvalue = \"true\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If options has a field [[<key>]], then\n\t\tif (\"key\" in options) {\n\t\t\t// Let optionsValue be options.[[<key>]].\n\t\t\tconst optionsValue = options.key;\n\n\t\t\t// Assert: Type(optionsValue) is either String, Undefined, or Null.\n\t\t\tif (typeof optionsValue !== \"string\" && optionsValue != null) {\n\t\t\t\tthrow new TypeError(`options value: '${optionsValue}' must be a string, undefined, or null`);\n\t\t\t}\n\n\t\t\t// If keyLocaleData contains optionsValue, then\n\t\t\tif (optionsValue !== undefined && keyLocaleData.includes(optionsValue)) {\n\t\t\t\t// If SameValue(optionsValue, value) is false, then\n\t\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\t\tif (!sameValue(optionsValue, value)) {\n\t\t\t\t\t// Let value be optionsValue.\n\t\t\t\t\tvalue = optionsValue;\n\t\t\t\t\t// Let supportedExtensionAddition be \"\".\n\t\t\t\t\tsupportedExtensionAddition = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set result.[[<key>]] to value.\n\t\tresult[key] = value;\n\n\t\t// Append supportedExtensionAddition to supportedExtension.\n\t\tsupportedExtension += supportedExtensionAddition;\n\t}\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","/**\n * The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a value that may be used as a property key.\n * https://tc39.es/ecma262/#sec-ispropertykey\n * @param {*} argument\n * @returns {boolean}\n */\nexport function isPropertyKey(argument: unknown): argument is PropertyKey {\n\t// If Type(argument) is String, return true.\n\tif (typeof argument === \"string\") return true;\n\t// If Type(argument) is Symbol, return true.\n\tif (typeof argument === \"symbol\") return true;\n\t// Return false.\n\treturn false;\n}\n","import {isPropertyKey} from \"./is-property-key\";\n\n/**\n * The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is called with arguments O and P where O is the object and P is the property key.\n * https://tc39.es/ecma262/#sec-get-o-p\n * @param {O} o\n * @param {P} p\n * @returns {O[P]}\n */\nexport function get<O extends object, P extends keyof O>(o: O, p: P): O[P] {\n\t// Assert: Type(O) is Object.\n\tif (typeof o !== \"object\") {\n\t\tthrow new TypeError(`Given argument ${o} must be of type Object`);\n\t}\n\n\t// Assert: IsPropertyKey(P) is true.\n\tif (!isPropertyKey(p)) {\n\t\tthrow new TypeError(`Given argument ${p} must be a PropertyKey`);\n\t}\n\treturn o[p];\n}\n","/**\n * The abstract operation ToBoolean converts argument to a value of type Boolean\n * https://tc39.es/ecma262/#sec-toboolean\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toBoolean(argument: unknown): boolean {\n\treturn Boolean(argument);\n}\n","import {get} from \"./get\";\nimport {toBoolean} from \"./to-boolean\";\nimport {toString} from \"./to-string\";\nimport {ElementOf} from \"./element-of\";\n\n/**\n * https://tc39.es/ecma402/#sec-getoption\n * @param {Options} options\n * @param {Property} property\n * @param {Type} type\n * @param {Values} values\n * @param {Fallback} fallback\n * @returns {Return}\n */\nexport function getOption<\n\tOptions extends object,\n\tProperty extends keyof Options,\n\tType extends Options[Property] extends (string | (string | undefined)) ? \"string\" : \"boolean\",\n\tValues extends Options[Property] extends (string | (string | undefined)) ? readonly string[] : readonly boolean[],\n\tFallback extends ElementOf<Values>,\n\tReturn extends ElementOf<Values>\n>(options: Options, property: Property, type: Type, values: Values, fallback: Fallback): Return {\n\t// Let value be ? Get(options, property).\n\tlet value = get(options, property);\n\t// If value is not undefined, then\n\tif (value !== undefined) {\n\t\t// Assert: type is \"boolean\" or \"string\".\n\t\tif (type !== \"boolean\" && type !== \"string\") {\n\t\t\tthrow new TypeError(`Expected type ${type} to be 'boolean' or 'string`);\n\t\t}\n\n\t\t// If type is \"boolean\", then\n\t\tif (type === \"boolean\") {\n\t\t\t// Let value be ToBoolean(value).\n\t\t\tvalue = (toBoolean(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If type is \"string\", then\n\t\tif (type === \"string\") {\n\t\t\t// Let value be ? ToString(value).\n\t\t\tvalue = (toString(value) as unknown) as Options[Property];\n\t\t}\n\n\t\t// If values is not undefined, then\n\t\tif (values !== undefined) {\n\t\t\t// If values does not contain an element equal to value, throw a RangeError exception.\n\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\tif (!values.includes(value as never)) {\n\t\t\t\tthrow new RangeError(`Value ${value} out of range for options property ${property}`);\n\t\t\t}\n\t\t}\n\n\t\t// Return value.\n\t\treturn (value as unknown) as Return;\n\t}\n\n\t// Else, return fallback.\n\telse {\n\t\treturn (fallback as unknown) as Return;\n\t}\n}\n","import {Locales} from \"../../locale/locales\";\nimport {toObject} from \"../../util/to-object\";\nimport {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\nimport {LOCALE_MATCHER, LocaleMatcher} from \"../../locale-matcher/locale-matcher\";\nimport {getOption} from \"../../util/get-option\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @return {Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\tlet matcher: LocaleMatcher;\n\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" », \"best fit\").\n\t\tmatcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\t}\n\n\t// Else, let matcher be \"best fit\".\n\telse {\n\t\tmatcher = \"best fit\";\n\t}\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\"\n\t\t? bestFitSupportedLocales(availableLocales, requestedLocales)\n\t\t: lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeFormatInstanceInternals} from \"./relative-time-format-instance-internals\";\nimport {RelativeTimeFormatStaticInternals} from \"./relative-time-format-static-internals\";\n\n/**\n * A WeakMap between RelativeTimeFormat instances and their internal slot members\n * @type {WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals>}\n */\nexport const RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for RelativeTimeFormat\n * @type {RelativeTimeFormatStaticInternals}\n */\nexport const RELATIVE_TIME_FORMAT_STATIC_INTERNALS: RelativeTimeFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « \"nu\" ».\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [\"nu\"],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @param {RelativeTimeFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T,\n\tvalue: RelativeTimeFormatInstanceInternals[T]\n): void {\n\tlet record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = Object.create(null) as RelativeTimeFormatInstanceInternals;\n\t\tRELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(\n\tinstance: RelativeTimeFormat,\n\tproperty: T\n): RelativeTimeFormatInstanceInternals[T] {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of RelativeTimeFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of RelativeTimeFormat exists\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T): boolean {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\n\n/**\n * When the ResolvePlural abstract operation is called with arguments pluralRules (which must be an object initialized as a PluralRules) and n (which must be a Number value), it returns a String value representing the plural form of n according to the effective locale and the options of pluralRules.\n *\n * https://tc39.github.io/ecma402/#sec-resolveplural\n * @param {RelativeTimeFormat} relativeTimeFormat - needed to get internal slots\n * @param {number} n\n */\nexport function resolvePlural(relativeTimeFormat: RelativeTimeFormat, n: number): string {\n\t// Assert: Type(pluralRules) is Object.\n\t// Assert: pluralRules has an [[InitializedPluralRules]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"pluralRules\")) {\n\t\tthrow new TypeError(`Given instance of of Intl.RelativeTimeFormat must have an [[InitializedPluralRules]] internal slot`);\n\t}\n\n\t// Assert: Type(n) is Number.\n\tif (typeof n !== \"number\") {\n\t\tthrow new TypeError(`Argument 'n' must be a number`);\n\t}\n\n\t// If n is not a finite Number, then\n\tif (!isFinite(n)) {\n\t\t// Return \"other\".\n\t\treturn \"other\";\n\t}\n\n\t// Let locale be pluralRules.[[Locale]].\n\t// Let type be pluralRules.[[Type]].\n\tconst pluralRules = getInternalSlot(relativeTimeFormat, \"pluralRules\");\n\n\t// Return ? PluralRuleSelect(locale, type, n, operands).\n\treturn pluralRules.select(n);\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (i % 2) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));\n    }\n  }\n\n  return target;\n}","import {SingularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The MakePartsList abstract operation is called with arguments pattern,\n * a pattern String, unit, a String, and parts, a List of Records representing a formatted Number.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-makepartslist\n * @param {string} pattern\n * @param {SingularRelativeTimeUnit} unit\n * @param {Intl.NumberFormatPart[]} parts\n * @returns {RelativeTimeFormatPart}\n */\nexport function makePartsList(pattern: string, unit: SingularRelativeTimeUnit, parts: Intl.NumberFormatPart[]): RelativeTimeFormatPart[] {\n\t// Let result be a new empty List.\n\tconst result: RelativeTimeFormatPart[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let endIndex be 0.\n\tlet endIndex = 0;\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of elements in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Set endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tendIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is not -1, otherwise the pattern would be malformed.\n\t\tif (endIndex === -1) {\n\t\t\tthrow new RangeError(`The pattern: '${pattern}' is malformed`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst p = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: p is \"0\".\n\t\tif (p !== \"0\") {\n\t\t\tthrow new TypeError(`Expected ${p} to be \"0\"`);\n\t\t}\n\n\t\t// For each part in parts, do\n\t\tfor (const part of parts) {\n\t\t\t// Add new part Record { [[Type]]: part.[[Type]], [[Value]]: part.[[Value]], [[Unit]]: unit } as a new element on the List result.\n\t\t\tif (part.type === \"literal\") {\n\t\t\t\tresult.push({...part, type: part.type});\n\t\t\t} else {\n\t\t\t\tresult.push({...part, unit});\n\t\t\t}\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, exclusive, to position length, exclusive.\n\t\t// CORRECTION: It should actually be from nextIndex, inclusive, to correctly partition text\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {ExtendedSingularRelativeTimeUnit, singularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\nimport {resolvePlural} from \"../resolve-plural/resolve-plural\";\nimport {makePartsList} from \"../make-parts-list/make-parts-list\";\nimport {toString} from \"../../util/to-string\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * When the FormatRelativeTime abstract operation is called with arguments relativeTimeFormat,\n * value, and unit it returns a String value representing value (interpreted as a time value as specified in ES2016, 20.3.1.1)\n * according to the effective locale and the formatting options of relativeTimeFormat.\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @returns {RelativeTimeFormatPart[]}\n */\nexport function partitionRelativeTimePattern(\n\trelativeTimeFormat: RelativeTimeFormat,\n\tvalue: number,\n\tunit: RelativeTimeUnit\n): RelativeTimeFormatPart[] {\n\t// Assert: relativeTimeFormat has an [[InitializedRelativeTimeFormat]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\tthrow new TypeError(`Internal function called on incompatible receiver ${relativeTimeFormat.toString()}`);\n\t}\n\n\t// Assert: Type(value) is Number.\n\tif (typeof value !== \"number\") {\n\t\tthrow new TypeError(`Argument: 'value' must be a number`);\n\t}\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`Argument: 'unit' must be a string`);\n\t}\n\n\t// If value is NaN, +∞, or -∞, throw a RangeError exception.\n\tif (isNaN(value) || value === Infinity || value === -Infinity) {\n\t\tthrow new RangeError(`Value need to be finite number`);\n\t}\n\n\t// Let unit be ? SingularRelativeTimeUnit(unit).\n\tunit = singularRelativeTimeUnit(unit);\n\n\t// Let fields be relativeTimeFormat.[[Fields]].\n\tconst fields = getInternalSlot(relativeTimeFormat, \"fields\");\n\n\t// Let style be relativeTimeFormat.[[Style]].\n\tconst style = getInternalSlot(relativeTimeFormat, \"style\");\n\n\t// If style is equal to \"short\", then let entry be the string-concatenation of unit and \"-short\".\n\t// Else if style is equal to \"narrow\", then let entry be the string-concatenation of unit and \"-narrow\".\n\t// Else let entry be unit.\n\tlet entry =\n\t\tstyle === \"short\"\n\t\t\t? (`${unit}-short` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: style === \"narrow\"\n\t\t\t? (`${unit}-narrow` as ExtendedSingularRelativeTimeUnit)\n\t\t\t: unit;\n\n\t// Let exists be ! HasProperty(fields, entry).\n\tlet exists = entry in fields;\n\n\t// If exists is false, then\n\tif (!exists) {\n\t\t// Let entry be unit.\n\t\tentry = unit;\n\t}\n\n\t// Let patterns be ! Get(fields, entry).\n\tconst patterns = fields[entry];\n\n\t// Make sure that the patterns are defined\n\tif (patterns == null) {\n\t\tthrow new TypeError(`Could not match entry: '${entry}' inside fields for locale: '${getInternalSlot(relativeTimeFormat, \"locale\")}'`);\n\t}\n\n\t// Let numeric be relativeTimeFormat.[[Numeric]].\n\tconst numeric = getInternalSlot(relativeTimeFormat, \"numeric\");\n\n\t// If numeric is equal to \"auto\", then\n\tif (numeric === \"auto\") {\n\t\t// Let exists be ! HasProperty(patterns, ! ToString(value)).\n\t\texists = toString(value) in patterns;\n\n\t\t// If exists is true, then\n\t\tif (exists) {\n\t\t\t// Let result be ! Get(patterns, ! ToString(value)).\n\t\t\tconst result = patterns[toString(value)];\n\n\t\t\t// Return a List containing the Record { [[Type]]: \"literal\", [[Value]]: result }.\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttype: \"literal\",\n\t\t\t\t\tvalue: result\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t}\n\n\t// If value is -0 or if value is less than 0, then let tl be \"past\".\n\t// Else let tl be \"future\".\n\tconst tl = Object.is(value, -0) || value < 0 ? \"past\" : \"future\";\n\n\t// Let po be ! Get(patterns, tl).\n\tconst po = patterns[tl];\n\n\t// Let fv be ! PartitionNumberPattern(relativeTimeFormat.[[NumberFormat]], value).\n\tconst fv = getInternalSlot(relativeTimeFormat, \"numberFormat\").formatToParts(Math.abs(value));\n\n\t// Let pr be ! ResolvePlural(relativeTimeFormat.[[PluralRules]], value).\n\tconst pr = resolvePlural(relativeTimeFormat, value);\n\n\t// Let pattern be ! Get(po, pr).\n\tconst pattern = po[pr];\n\n\t// Return ! MakePartsList(pattern, unit, fv).\n\treturn makePartsList(pattern, unit, fv);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\n\n/**\n * The FormatRelativeTime abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit) and performs the following steps:\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTime\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {string}\n */\nexport function formatRelativeTime(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): string {\n\t// Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit).\n\tconst parts = partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to the string-concatenation of result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\t// Return result.\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The FormatRelativeTimeToParts abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit)\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTimeToParts\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {RelativeTimeFormatPart[]}\n */\nexport function formatRelativeTimeToParts(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\treturn partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n}\n","/**\n * The abstract operation ToNumber converts argument to a value of type Number\n * https://tc39.es/ecma262/#sec-tonumber\n * @param {*} argument\n * @returns {boolean}\n */\nexport function toNumber(argument: unknown): number {\n\treturn Number(argument);\n}\n","import {Locale} from \"../../locale/locale\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelativeTimeFormatOptions} from \"./relative-time-format-options\";\nimport {toObject} from \"../../util/to-object\";\nimport {toString} from \"../../util/to-string\";\nimport {InputLocaleDataEntry} from \"../../locale/locale-data\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {SupportedLocalesOptions} from \"../supported-locales/supported-locales-options\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {formatRelativeTime} from \"../format-relative-time/format-relative-time\";\nimport {getInternalSlot, hasInternalSlot, RELATIVE_TIME_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {IntlPluralRulesConstructor} from \"../../intl-object/intl-object\";\nimport {formatRelativeTimeToParts} from \"../format-relative-time-to-parts/format-relative-time-to-parts\";\nimport {ResolvedRelativeTimeFormatOptions} from \"./resolved-relative-time-format-options\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\nimport {getOption} from \"../../util/get-option\";\nimport {LOCALE_MATCHER} from \"../../locale-matcher/locale-matcher\";\nimport {STYLE} from \"../../style/style\";\nimport {NUMERIC} from \"../../numeric/numeric\";\nimport {toNumber} from \"../../util/to-number\";\nimport {RelativeTimeFormatPart} from \"../../relative-time-format-part/relative-time-format-part\";\n\n/**\n * The RelativeTimeFormat constructor is the %RelativeTimeFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-intl-relativetimeformat-constructor\n */\nexport class RelativeTimeFormat {\n\t// The spec states that the constructor must have a length of 0 and therefore be parameter-less\n\tconstructor() {\n\t\tconst locales = arguments[0] as Locale | Locales | undefined;\n\t\tlet options = arguments[1] as Partial<RelativeTimeFormatOptions>;\n\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.RelativeTimeFormat requires 'new'`);\n\t\t}\n\n\t\t// The following operations comes from the 'InitializeRelativeFormat' abstract operation (http://tc39.github.io/proposal-intl-relative-time/#sec-InitializeRelativeTimeFormat)\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<RelativeTimeFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record (that doesn't derive from Object.prototype).\n\t\tconst opt = Object.create(null) as RelativeTimeFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", «\"lookup\", \"best fit\"»,  \"best fit\").\n\t\tconst matcher = getOption(options, \"localeMatcher\", \"string\", LOCALE_MATCHER, \"best fit\");\n\n\t\t// Set opt.[[LocaleMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let localeData be %RelativeTimeFormat%.[[LocaleData]].\n\t\tconst localeData = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %RelativeTimeFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales,\n\t\t\trequestedLocales,\n\t\t\topt,\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.relevantExtensionKeys,\n\t\t\tlocaleData\n\t\t);\n\n\t\t// Let locale be r.[[Locale]].\n\t\tconst locale = r.locale;\n\n\t\t// Set relativeTimeFormat.[[Locale]] to locale.\n\t\tsetInternalSlot(this, \"locale\", locale);\n\n\t\t// Set relativeTimeFormat.[[NumberingSystem]] to r_.[[nu]].\n\t\tsetInternalSlot(this, \"numberingSystem\", r.nu);\n\n\t\t// Let dataLocale be r.[[DataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let s be ? GetOption(options, \"style\", \"string\", «\"long\", \"short\", \"narrow\"», \"long\").\n\t\tconst s = getOption(options, \"style\", \"string\", STYLE, \"long\");\n\n\t\t// Set relativeTimeFormat.[[Style]] to s.\n\t\tsetInternalSlot(this, \"style\", s);\n\n\t\t// Let numeric be ? GetOption(options, \"numeric\", \"string\", «\"always\", \"auto\"», \"always\").\n\t\tconst numeric = getOption(options, \"numeric\", \"string\", NUMERIC, \"always\");\n\n\t\t// Set relativeTimeFormat.[[Numeric]] to numeric.\n\t\tsetInternalSlot(this, \"numeric\", numeric);\n\n\t\t// Let fields be ! Get(localeData, dataLocale).\n\t\tconst fields = localeData[dataLocale];\n\n\t\t// Assert: fields is an object (see 1.3.3).\n\t\tif (!(fields instanceof Object)) {\n\t\t\tthrow new TypeError(`Expected the LocaleDataEntry for locale: '${dataLocale}' to be an Object`);\n\t\t}\n\n\t\t// Set relativeTimeFormat.[[Fields]] to fields.\n\t\tsetInternalSlot(this, \"fields\", fields);\n\n\t\t// Let relativeTimeFormat.[[NumberFormat]] be ! Construct(%NumberFormat%, « locale »).\n\t\tsetInternalSlot(this, \"numberFormat\", new Intl.NumberFormat(locale));\n\n\t\t// Let relativeTimeFormat.[[PluralRules]] be ! Construct(%PluralRules%, « locale »).\n\t\t// tslint:disable-next-line:no-any\n\t\tsetInternalSlot(\n\t\t\tthis,\n\t\t\t\"pluralRules\",\n\t\t\tnew ((Intl as unknown) as {\n\t\t\t\tPluralRules: IntlPluralRulesConstructor;\n\t\t\t}).PluralRules(locale)\n\t\t);\n\n\t\t// Intl.RelativeTimeFormat instances have an [[InitializedRelativeTimeFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedRelativeTimeFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @return {Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales): Locales {\n\t\t// The spec states that the 'length' value of supportedLocalesOf must be equal to 1,\n\t\t// so we have to pull the options argument out of the method signature\n\t\tconst options = arguments[1] as SupportedLocalesOptions | undefined;\n\n\t\t// Let availableLocales be %RelativeTimeFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Method that formats a value and unit according to the locale and formatting options of this Intl.RelativeTimeFormat object.\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {string}\n\t */\n\tpublic format(value: number, unit: RelativeTimeUnit): string {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTime(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTime(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * A version of the 'format' method that returns an array of objects which represent \"parts\" of the object,\n\t * separating the formatted number into its constituent parts and separating it from other surrounding text\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {RelativeTimeFormatPart[]}\n\t */\n\tpublic formatToParts(value: number, unit: RelativeTimeUnit): RelativeTimeFormatPart[] {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = toNumber(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = toString(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTimeToParts(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTimeToParts(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedRelativeTimeFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedRelativeTimeFormatOptions {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\t\tconst numeric = getInternalSlot(this, \"numeric\");\n\t\tconst numberingSystem = getInternalSlot(this, \"numberingSystem\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\tstyle,\n\t\t\tnumeric,\n\t\t\tnumberingSystem\n\t\t};\n\t}\n}\n\n/**\n * The initial value of the @@toStringTag property is the string value \"Intl.RelativeTimeFormat\".\n * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n * @type {string}\n */\nObject.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {\n\twritable: false,\n\tenumerable: false,\n\tvalue: \"Intl.RelativeTimeFormat\",\n\tconfigurable: true\n});\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format/relative-time-format\";\n\n/**\n * Patches Intl with Intl.RelativeTimeFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(\n\t\t\t`Could not define Intl.RelativeTimeFormat: Expected 'Intl' to exist. Remember to include polyfills for Intl.NumberFormat, Intl.getCanonicalLocales, and Intl.PluralRules before applying this polyfill`\n\t\t);\n\t}\n\tIntl.RelativeTimeFormat = RelativeTimeFormat;\n}\n","import {SUPPORTS_RELATIVE_TIME_FORMAT} from \"./support/supports-relative-time-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_RELATIVE_TIME_FORMAT) {\n\tpatch();\n}\n"],"names":["defineProperty"],"mappings":"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"}